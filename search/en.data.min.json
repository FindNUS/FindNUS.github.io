[{"id":0,"href":"/ms2/swe/apisample/","title":"Actual FindNUS API for Milestone 2","parent":"Software Engineering Documentation","content":"From this line below, it is the Markdown API documentation that is stored on the working backend repository for developers to reference and use.\nFindNUS_api API documentation for FindNUS backend services. Handles the retrieval, processing and management of Lost Items found in NUS.\nTable of Contents Servers Paths GET /debug/ping GET /debug/checkAuth GET /debug/getDemoItem POST /item PATCH /item GET /item DELETE /item GET /item/peek GET /search Schemas Item MiniItem NewItem DeleteItem PatchItem Category ContactMethod ## Servers URL Description https://findnus.herokuapp.com Production cluster that is hosting the backend services for FindNUS https://uat-findnus.herokuapp.com User-Acceptance Testing cluster environment for testing Paths GET /debug/ping Returns a Hello World equivalent message. Shows that the backend connection works.\nResponses ▶ 200 - A hello world message. Headers No headers specified\ntext/plain Name Type Description Accepted values Response string Any Example message: Hi there, you have reached FindNUS! GET /debug/checkAuth Check with backend if the Firebase token is valid.\nHeaders ▷ Authorization Firebase ID token of user\nName Type In Description Accepted values Authorization (required) string header Firebase ID token of user Any Example \u0026#34;Authorization: my-firebase-idToken\u0026#34; Responses ▶ 200 - Id token is valid Headers No headers specified\n▶ 401 - Id token is invalid Headers No headers specified\nGET /debug/getDemoItem Get a demo item for Milestone 1.\nQuery parameters ▷ name Name of the demoset item to be retrieved\nName Type In Description Accepted values name (required) string query Name of the demoset item to be retrieved Any Responses ▶ 200 - Get request is valid, item is found Headers No headers specified\napplication/json Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any Name (required) string Name of lost/found item Any Date (required) string Date-time where item is lost/found Any Location (required) string Where the item was found Any Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_url string Item's accompanying image link Any User_id string UserID associated to this item. Only applicable for Lookout Items. Any Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgur.com/gallery/RaHyECD\u0026#34;, \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34; } ▶ 404 - Get request is valid, item not found Headers No headers specified\ntext/plain Name Type Description Accepted values Response string Any Example Nothing Found! POST /item Add new Lost item to be put on Lookout on the database.\nHeaders ▷ Authorization Firebase ID token of user\nName Type In Description Accepted values Authorization (required) string header Firebase ID token of user Any Example \u0026#34;Authorization: my-firebase-idToken\u0026#34; Request body application/json Name Type Description Accepted values User_id string Unique User_id generated by firebase to associate a user to a Lookout item. Any Name (required) string Name of new lost/found item Any Date (required) string Date-time where item is lost/found Any Location (required) string Where the item was found Any Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_base64 string Accompanying image of new Lost/Found item, if applicable Any Example (generated) { \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_base64\u0026#34;: \u0026#34;string\u0026#34; } Responses ▶ 200 - Item registered into database Headers No headers specified\n▶ 400 - Rejected new item into database Headers No headers specified\n▶ 401 - Firebase credentials not invalid Headers No headers specified\nPATCH /item Update details of an item on the database.\nHeaders ▷ Authorization Firebase ID token of user\nName Type In Description Accepted values Authorization (required) string header Firebase ID token of user Any Example \u0026#34;Authorization: my-firebase-idToken\u0026#34; Query parameters ▷ Id MongoDB ID of the Item\nName Type In Description Accepted values Id (required) string query MongoDB ID of the Item Any Example \u0026#34;Id=629cc52563533a84f60c4c68\u0026#34; ▷ User_id FindNUS User Id (for lost item lookout requests). Include this to remove from Lost (Lookout) Items collection.\nName Type In Description Accepted values User_id (required) string query FindNUS User Id (for lost item lookout requests). Include this to remove from Lost (Lookout) Items collection.\nAny Example \u0026#34;User_id=196afas7\u0026#34; Request body application/json Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any User_id string Unique User_id generated by firebase to associate a user to a Lookout item. Any Name string Name of new lost/found item Any Date string Date-time where item is lost/found Any Location string Where the item was found Any Category string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_base64 string Updated image of Lost/Found item, if applicable Any Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_base64\u0026#34;: \u0026#34;string\u0026#34; } Responses ▶ 200 - OK Headers No headers specified\n▶ 401 - Firebase credentials not invalid Headers No headers specified\nGET /item Get a particular item\u0026rsquo;s full details\nQuery parameters ▷ Id Item Id reference. Case sensitive.\nName Type In Description Accepted values Id (required) string query Item Id reference. Case sensitive. Any ▷ User_id User_id filter to search for this Id in the LOST collection. Case sensitive.\nName Type In Description Accepted values User_id string query User_id filter to search for this Id in the LOST collection. Case sensitive. Any Responses ▶ 200 - A Lost Item\u0026rsquo;s details Headers No headers specified\napplication/json Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any Name (required) string Name of lost/found item Any Date (required) string Date-time where item is lost/found Any Location (required) string Where the item was found Any Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_url string Item's accompanying image link Any User_id string UserID associated to this item. Only applicable for Lookout Items. Any Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgur.com/gallery/RaHyECD\u0026#34;, \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34; } ▶ 404 - Item not found Headers No headers specified\n▶ 500 - Internal server error. Likely to be a message queue fault. Headers No headers specified\nDELETE /item Remove an item listing on the database.\nHeaders ▷ Authorization Firebase ID token of user\nName Type In Description Accepted values Authorization (required) string header Firebase ID token of user Any Example \u0026#34;Authorization: my-firebase-idToken\u0026#34; Query parameters ▷ Id MongoDB ID of the Item\nName Type In Description Accepted values Id (required) string query MongoDB ID of the Item Any Example \u0026#34;Id=629cc52563533a84f60c4c68\u0026#34; ▷ User_id FindNUS User_Id (for lost item lookout requests). Include this to remove from Lost (Lookout) Items collection. Case sensitive.\nName Type In Description Accepted values User_id string query FindNUS User_Id (for lost item lookout requests). Include this to remove from Lost (Lookout) Items collection. Case sensitive.\nAny Example \u0026#34;User_id=196afas7\u0026#34; Request body application/json Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34; } Responses ▶ 200 - Deletion request received and will be processed if the item exists. Headers No headers specified\n▶ 401 - Firebase credentials not invalid Headers No headers specified\nGET /item/peek Get a list of lost items sorted by date. These items are paginated and filtered by category, if requested. The default returns the latest 20 items, with no category filter.\nQuery parameters ▷ offset Number of items to skip (Case sensitive)\nName Type In Description Accepted values offset integer query Number of items to skip (Case sensitive) Any ▷ limit Number of items to return (Case sensitive)\nName Type In Description Accepted values limit integer query Number of items to return (Case sensitive) Any ▷ category Types of category to filter by. Chain multiple category values to filter by the For example, category=Cards\u0026amp;category=Etc will include results from both Cards and Etc.\nName Type In Description Accepted values category string query Types of category to filter by. Chain multiple category values to filter by the For example, category=Cards\u0026amp;category=Etc will include results from both Cards and Etc.\nAny Responses ▶ 200 - Returns an array of lost items that may be filtered Headers No headers specified\napplication/json Name Type Description Accepted values Response array(object) Any Response.Id (required) string The MongoDB ObjectID associated to this Item Any Response.Name (required) string Name of lost/found item Any Response.Date (required) string Date-time where item is lost/found Any Response.Location (required) string Where the item was found Any Response.Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Response.Image_url string Item's accompanying image link Any Example (generated) [ { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgur.com/gallery/RaHyECD\u0026#34; } ] ▶ 500 - Internal server error. Likely to be a message queue fault. Headers No headers specified\nGET /search Text-based search for an item.\nQuery parameters ▷ query Text query to search for lost items. Can be any arbitrary string - the ElasticSearch engine will attempt to best-match the query. The query will be performed over the FOUND collection\u0026rsquo;s Name, Category, Location and Item Detail fields.\nName Type In Description Accepted values query string query Text query to search for lost items. Can be any arbitrary string - the ElasticSearch engine will attempt to best-match the query. The query will be performed over the FOUND collection's Name, Category, Location and Item Detail fields.\nAny Responses ▶ 200 - Returns an array of Found items that were matched to the query string. Headers No headers specified\napplication/json Name Type Description Accepted values Response array(object) Any Response.Id (required) string The MongoDB ObjectID associated to this Item Any Response.Name (required) string Name of lost/found item Any Response.Date (required) string Date-time where item is lost/found Any Response.Location (required) string Where the item was found Any Response.Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Response.Image_url string Item's accompanying image link Any Example (generated) [ { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgur.com/gallery/RaHyECD\u0026#34; } ] ▶ 500 - Internal server error. Likely to be a message queue fault. Headers No headers specified\nSchemas Item Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any Name (required) string Name of lost/found item Any Date (required) string Date-time where item is lost/found Any Location (required) string Where the item was found Any Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_url string Item's accompanying image link Any User_id string UserID associated to this item. Only applicable for Lookout Items. Any Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgur.com/gallery/RaHyECD\u0026#34;, \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34; } MiniItem Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any Name (required) string Name of lost/found item Any Date (required) string Date-time where item is lost/found Any Location (required) string Where the item was found Any Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Image_url string Item's accompanying image link Any Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgur.com/gallery/RaHyECD\u0026#34; } NewItem Name Type Description Accepted values User_id string Unique User_id generated by firebase to associate a user to a Lookout item. Any Name (required) string Name of new lost/found item Any Date (required) string Date-time where item is lost/found Any Location (required) string Where the item was found Any Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_base64 string Accompanying image of new Lost/Found item, if applicable Any Example (generated) { \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_base64\u0026#34;: \u0026#34;string\u0026#34; } DeleteItem Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34; } PatchItem Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any User_id string Unique User_id generated by firebase to associate a user to a Lookout item. Any Name string Name of new lost/found item Any Date string Date-time where item is lost/found Any Location string Where the item was found Any Category string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_base64 string Updated image of Lost/Found item, if applicable Any Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_base64\u0026#34;: \u0026#34;string\u0026#34; } Category Name Type Description Accepted values Category string Non-case sensitive category name Etc, Cards, Notes, Electronics, Bottles Example (generated) \u0026#34;Etc\u0026#34; ContactMethod Name Type Description Accepted values ContactMethod string Non-case sensitive contact method nus_security, telegram, whatsapp, wechat, line, phone_number Example (generated) \u0026#34;nus_security\u0026#34; "},{"id":1,"href":"/ms2/technical/backend/","title":"Backend Technical Documentation","parent":"Technical Documentation","content":" Table of contents Key Technologies High-Level Overview Integration Details Recieving HTTP requests from frontend Sending messages between microservices Ensuring Thread-safe communication Creating, removing and updating, deleting Items Image storage with Imgur Synchronising the Search Engine Appendix A: Backend Design Choices Architecture: Microservice Platform: Heroku Additional Considerations Database: MongoDB Message Broker: RabbitMQ Search Engine: Elasticsearch Language: Golang Image storage: Imgur In this page, we document:\nThe key technologies used The high-level overview of the Backend The integration details Specifically, this is a deep dive into how the various technologies are interfaced with each other. Why certain technologies?1\nKey Technologies This is a list of the technologies that we have used to build the backend.\nGolang (Language) Gin-gonic (HTTP Router) Docker (Runtime) RabbitMQ (Message Broker)2 Heroku (PaaS) MongoDB (Database) Bonsai ElasticSearch (Search Engine) Firebase (Authentication) Imgur (3rd Party API) High-Level Overview This figure shows how the backend roughly works as a whole unit to provide the backend API for FindNUS\u0026rsquo; business logic. As of Milestone 2, we deployed 2 microservices, backend and item.\nBackend is in charge of routing and item is in charge of CRUD. The next section takes a closer look into HOW the technologies are integrated with each other.\nIntegration Details This section dives deep into how the technology is integrated with one another to produce a cohesive backend. We will explain the integration through events.\nRecieving HTTP requests from frontend Technologies Integrated (TI): Golang, Docker, Heroku\nThe frontend needs things to be done, such as POSTing new items or GETting items from the database. This is done through the backend providing an API using the HTTP.\nThese requests enter Heroku\u0026rsquo;s platform and are forwarded to our Backend microservice. To actually use these requests, integration is needed between our Docker runtime and Heroku\u0026rsquo;s platform.\nHeroku sends HTTP requests through a PORT env variable. We just need to get the port details and we can plug it into our logic to process the http requests.\nSnippet:\nport := os.Getenv(\u0026#34;PORT\u0026#34;) if port == \u0026#34;\u0026#34; { // App is running locally port = \u0026#34;8080\u0026#34; } Using Gin-gonic, we can create a HTTP router to listen to the http requests coming in via PORT. We can also ignore malicious/invalid requests by configuring the Cross-Origin settings.\nSnippet:\nrouter := gin.Default() router.Use( cors.New(cors.Config{ AllowAllOrigins: true, AllowHeaders: []string{\u0026#34;Origin\u0026#34;, \u0026#34;Authorization\u0026#34;, \u0026#34;Content-Type\u0026#34;, \u0026#34;Access-Control-Allow-Headers\u0026#34;}, AllowMethods: []string{\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PATCH\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;OPTIONS\u0026#34;}, AllowCredentials: true, }), ) // ...Additional logic, omitted for brevity // Listen for HTTP requests router.Run(\u0026#34;:\u0026#34; + port) Sending messages between microservices TI: Golang, RabbitMQ\nIn the microservices architecture, business logic is seperated into different runtimes/containers based on function.\nWe will need to pass information between these runtimes, for example, the Backend Microservice needing to get a item\u0026rsquo;s detail from the Item Microservice.\nThe microservices are blocked from using HTTP communication between one another due to Heroku policy. So, instead of HTTP, we need to leverage on a message broker with its own communication protocol, RabbitMQ to coordinate messages between these microservices.\nIn summary, using RabbitMQ, we defined three queues to send our own messages.\nItem Queue q_item\nHandles one-off messages that require no return response, such as POST and DELETE.\nRemote Proceedure Call (RPC)3 Queue q_get_req, q_get_resp\nHandles messages that require a return response, such as GET and search queries.\nThe below image illustrates the communciation pipelines between the 2 microservices using RabbitMQ.\nEnsuring Thread-safe communication In particular, when integrating Golang with RabbitMQ to implement the RPC pattern, each RPC job needs to be given a unique correlation_id to identify which RPC call the request belongs to. This is not implemented by the golang driver provided. So we created our own thread-safe unique correlation_id generator.\nThread safety is needed via sync.Mutex as the HTTP requests are processed in-parallel, so there is a risk that multiple RPC subroutines may have the same correlation_id, which will cause bugs.\nFurther, we DO NOT use randomly generated numbers as there is no guarantee that the randomly generated numbers won\u0026rsquo;t be the same for 2 concurrent RPCs that call the random generator.\nSnippet:\n// JobID Unique Job ID. Overflows are OK type JobId struct { mu sync.Mutex id uint64 } var rpcJobId JobId // Thread-safe jobId implementation func GetJobId() uint64 { // Force one goroutine to access jobId at a time // To prevent a race condition rpcJobId.mu.Lock() defer rpcJobId.mu.Unlock() rpcJobId.id += 1 jobId := rpcJobId.id return jobId } Creating, removing and updating, deleting Items TI: MongoDB, Imgur, Elasticsearch\nThere are many moving parts and integrations in the CRUD logic. So, a diagram explaining one of the processes, POSTing a new item:\nUpdating and deleting items follow a very similar control flow, but is omitted for now due to repetition.\nThe important integration details explained below:\nImage storage with Imgur When a new item is added with a raw base_64 string representing the user-submitted image, we store it on imgur. Imgur returns a deleteHash key for us to delete the image, as well as a link to the stored image. We store the hash and link on a Imgur reference database collection to manage our Imgur links.\nFor delete item operations, the deleteHash is obtained from the Imgur collection to properly dispose of our Imgur image.\nSynchronising the Search Engine Elasticsearch runs its own database store in order to index it properly to provide powerful searching capabilities. This means that we need to sync information between MongoDB and Elasticsearch.\nWe have explored solutions such as industry-tested Logstash and open-source \u0026lsquo;River\u0026rsquo;, but they are either paid or are outdated for our version of Elasticsearch.\nSo, we settled on writing the database synchronisation logic ourselves in order to fully interface MongoDB and ElasticSearch.\nWe wrote equivalent CRUD operations on Elasticsearch for their MongoDB counterpart. If an item needs to be Added/Updated/Removed from MongoDB, a parallel and equivalent operation will be done on Elasticsearch.\nSnippet of a ElasticSearch Item Addition:\n// Handler for Adding Item func ElasticAddItem(item ElasticItem) { // Check for item existence first as a safety catch to avoid redundant (the bad kind) copies if ElasticGetItem(item.Id) != (ElasticItem{}) { // Item already exists! This is likely an update. Delete it and re-add in. // Deletion rather than patching is done due to paywalled API log.Println(\u0026#34;Deleting\u0026#34;) ElasticDeleteItem(item.Id) } res, err := EsClient.Index().Index(IndexName).BodyJson(item).Do(context.Background()) if err != nil { log.Fatal(err) } log.Println(\u0026#34;Add item response:\u0026#34;, res) } Appendix A: Backend Design Choices The following was initially documented with references in Milestone 1. As it is important technical information, it is brought over here for documentation sake. Link to the original document.\nArchitecture: Microservice The backend’s overall function is to provide the front-facing web application a bunch of callable APIs. There are two general architectures to designing backend APIs6. Monolithic – business logic \u0026amp; functionality are compiled to one large application. Microservices – business logic \u0026amp; functions are factored out into logically grouped ‘services’ that are isolated from one another. They and communicate through communication protocols such as HTTP or remote procedure calls (RPC).\nFactor Microservices Monolith Speed of development Needs more initial groundwork to setup the backend infrastructure Scales very fast initially, but is harder to maintain the bigger the project Coupling \u0026amp; Redundancy Each microservice is loosely coupled: They work independently of one another, making it fault tolerant Tightly coupled components: changing something may break the entire app Flexibility Each microservice can be built with completely different languages, dependencies and even tech stacks Very difficult to change the tech stack the deeper the application is in development Feature Scalability Scales well in the long run due to loose coupling of components Diminishing scaling speed due to tight coupling of components Load Scalability Scales horizontally – able to serve more consumers by simply launching more microservice nodes Scales vertically, which is expensive and will cause downtime Testing Each microservice needs to be tested separately, with different scripts End to end testing is easier as it only needs to be done on one application Ultimately, we chose to implement FindNUS using microservices architecture, primarily due to the factors highlighted in green. This is because:\nLoose coupling allows for redundancy. If some feature breaks, it will not take down the whole application with it. It also pinpoints us to the failing service for expedient debugging. This is important for Lost and Found services, which should be up 24/7 and cannot afford downtime.\nIts high flexibility allows us to add various feature without breaking core functionality. For example, adding future features that require drastically different tech-stacks such as Machine-learning powered Lost-and-found matching (Python + TensorFlow) can be added with ease without breaking the core components already in place.\nIts horizontal scalability allows us to scale FindNUS just-in-time based on real-time user load, minimising costs of running computational resources on Heroku and MongoDB.\nPlatform: Heroku To host our services, we needed something to host the backend code. We deliberated between cloud platform (s.a. Heroku, AWS), renting an actual server (s.a. Linode) and going serverless.\nFactor Cloud/PaaS (Heroku) Actual Server (Linode) Serverless (Netlify, AWS Lambda) Load Scalability Easily scalable with built-in load balancers Need to manually handle load balancing and scaling by using tools such as Kubernetes Easily scalable since the API triggers are handled by serverless calls Uptime Always on Always on Slower – tends to require more time due to cold start Cost Bounded to ‘free-tier’ limits Most expensive: restrictive trial period Bounded to number of API calls made (including testing). Security Abstracted away by cloud provider Manual setup needed. Require a sysadmin’s expertise to fully secure it Abstracted away by serverless provider Testing Comes with various free logging service and CICD tools built-in Need to setup all testing tools manually Few (free) tools for testing, logging and debugging available. Harder in nature due to reduced visibility of backend processes Ultimately, PaaS was chosen in favour of renting actual servers or going serverless. PaaS gives us the best middle ground. It provides flexibility to build FindNUS efficiently with high uptime and debugging visibility. Yet, have the more time-consuming and tedious backend groundwork such as security and load balancing abstracted away for us.\nFactor Heroku AWS Firebase Cost Free Forever Most tools only have free trial for 1 year Vast suite of free tools forever, excluding computational resources (Cloud Functions) CPU Hours 1000/mo. 750/mo., 1-year free trial N.A. Among the PaaS providers, Heroku wins out the traditional PaaS go-tos such as Firebase and AWS as it provides us the most CPU hours and is the lowest cost amongst them.\nAdditional Considerations Region Placement: Minimising latency. We had the choice between two regions for Heroku free-tier hosting, the EU and USA. We researched and realised that Heroku is hosted by AWS in Virginia (USA) and Ireland (EU)11. Based on an open cloud pinging service12, we determined that Heroku’s EU/Ireland region is the fastest (Annex D). Hence, we used the EU region and placed all other backend helper services (such as MongoDB Atlas) in the same region (EU/Ireland by AWS) in order to reduce latency between these components.\nDatabase: MongoDB MongoDB is a document-based database system. It stores data primarily via a key-value store. This was chosen in favour of traditional relational databases such as PostgreSQL due to the nature of the Lost and Found (LNF) process. LNF items can be potentially registered in a myriad of ways, from photos to NUS security to even voice recording.\nFlexible schema. MongoDB, being document-based, allows flexible scaling of object schema without breaking the whole table. We can phase in more LNF Item data properties as we scale features without breaking the entire table to allow voice recording, video bubble links, GeoJSON, “isWithNusSecurity” flags and more. This is not doable with SQL.\nEase of use. There is no need for normalization13. This makes obtaining data easier since there is no need to join multiple tables from a normalized SQL database. Every parameter can be accessed straight from a document database.\nSchema: Optimising memory usage. As defined in Annex E, certain fields such as item category are stored as 32-bit integers rather than strings. Internally on the backend, there will be mapping logic converting the integers to and from their associated strings (s.a. 1 -\u0026gt; Cards, 2 -\u0026gt; Umbrella). This is done so to optimise each Item’s memory size. A 32-bit integer (4 bytes) holds less memory space compared to a string with at least 4 characters.\nMessage Broker: RabbitMQ Why do we need a message broker? For some context, in the Heroku environment, individual microservices are wrapped in containers called “Dynos”. These dynos are secured in the network and cannot communicate to one another14 over TCP. Hence, a communication protocol is required to pass information from one microservice container to the other for ‘work’ such as CRUD to be done.\nWe compared between three communication protocols that define how isolated containers can talk to each other: Remote procedure calls (RPC), REST and Message Queueing.\nFactor RPC REST Message Queues (MQ) Heroku Support Possible with RPC-enabling message brokers Impossible, inter-container TCP communication is not allowed Possible Speed Fastest Slower than RPC Slowest Load Stability Less stable Stable Stable Message stability Messages can get lost and is unrecoverable Message loss is recoverable due to TCP handshake protocol Messages are persistent and guaranteed to be delivered Since Heroku does not provide support for REST architecture for inter-container communication, we are forced to use RPC and Message Queuing, which is the recommended way to do so (w.r.t. footnote 12). To use RPC \u0026amp;/or MQ, we need a message broker. We chose CloudAMQP (RabbitMQ) as it has extensive documentation on integration with Heroku20.\nRabbitMQ is flexible – it allows us to use message queues and RPC21. Rather than stick to one communication protocol, we plan to use both RPC and MQ as both protocols are best suited for certain use cases.\nRPC: Searching. RPC is very fast compared to the other protocols. This makes it suitable for short-lived operations that require quick responses, such as searching and autocompletion (Elasticsearch API calls). Even if the message is lost, it is tolerable in the case of autocompletion and just-in-time searching.\nMQ: Database CRUD. There are certain operations that need stability and data persistence. When submitting LNF requests/items, the end-user is likely to only POST the request once and leave the application. We cannot afford the situation where a user submits an item request/registration, but the message gets lost halfway in the backend and the item is not registered in the database. MQs can be configured to guarantee delivery and data persistence22, this adds stability to the CRUD process which is critical to the Lost-and-found process.\nSearch Engine: Elasticsearch Elasticsearch (ES) was chosen as the search engine for our application due to the nature of our LNF item schema. Effective searches for lost items rely heavily on string-based parameters such as its name and item details. Further, the “Item_details” is effectively full text, where the users write a long description of the item which allows for flexibility in registering LNF items. For example, an item detail can be: “the bottle’s handle is broken, and it has a NUS sticker on it”.\nFull-text search. ES was built with text searching in mind23. It is optimised for indexing and searching through large bodies of text, such as the “Item_details” parameter. Although it is entirely possible to use full-text searches on SQL and even MongoDB, it is far simpler and to implement via ES. Most importantly, ES outperforms24 other competitors in querying speed.\nLanguage: Golang Golang is a widely used server-side language. Compared to other languages, we chose Golang for the following reasons:\nGolang is a relatively fast25 server-side language. Easy to use HTTP server library that is concurrent26 by nature. (https://github.com/gin-gonic/gin) Unit-testing is built into the language and is simple to make and run. Image storage: Imgur Images tell a thousand words, which is why we included Images as part of the schema to submit a new item to the LNF database (Annex C). It is easier to identify lost items from pictures than wordy text. However, images take up a lot of space. To estimate storage requirements, we assumed that an average smartphone takes 12MP images which is about 3.6MB28 per photo. Our free-tier MongoDB has a storage limit of 512MB. If we only used it to store images, we can fit approximately 142 images, which is very small.\nThe above estimation discounts the fact that smartphone cameras are getting even more powerful, with the upper limit going as high as 108MP (approx. 30MB/photo). Even if we use lossy compression, the disk space required by photos will still be in the order of megabytes. Hence, we cannot afford to directly store images on our backend servers.\nWe decided to use Imgur as a 3rd party image hosting service to offload the storage needs for FindNUS. This is because it has a generous upload limit of 1250 images per day (52 images per hour) and image URL endpoints are persistent.\nIn Milestone 1, we documented in-depth why we used certain technologies instead of another. Link to the document\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nA message broker is needed to communicate between docker containers. This is a heroku perculiarity as the docker containers cannot talk to each other via HTTP due to security policy. In industry, message brokers are often used to coordinate work as well.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nA RPC is something like a synchronous GET request. It enables two computers in seperate locations to send information to each other. A primer if you are interested\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":2,"href":"/ms2/uiux/unittesting/","title":"Code Testing","parent":"UI UX and Testing","content":" Table of Contents Frontend Overview Unit Testing Integration Testing User Acceptance Testing Backend Overview Unit Testing Example 1: Data Mocking - Data Preprocessing Valid Lost Item Testcases (Truncated) Invalid Lost Item Testcases Example 2: HTTP Request Mocking - Testing Route Handlers Example 3: Load Testing: High Concurrency Test Regression Testing User Acceptance Testing Frontend Overview We perform unit and integration testing with Jest and React Testing Library on the application. For Milestone 2, we focus on testing selected components. Test cases will be expanded for Milestone 3, with more components and end-to-end testing. Using Jest, we are able to use the describe and it functions to perform our tests. This is combined with the render and screen from React Testing Library which acts as a bridge between Jest and the components. The test code is executed with the command npm test.\nBack to top Unit Testing We focus on the trivial case of a button component, which is expected to display content based on its input\ndescribe(\u0026#34;Button component\u0026#34;, () =\u0026gt; { const testClass = \u0026#34;btn btn--primary\u0026#34;; const sampleText = \u0026#34;Lorem ipsum\u0026#34;; it(\u0026#34;has the correct class\u0026#34;, () =\u0026gt; { const { getByText } = render( \u0026lt;Button class={testClass} text={sampleText} /\u0026gt; ); const btn = getByText(sampleText); expect(btn).toHaveClass(testClass); }); it(\u0026#34;text renders properly\u0026#34;, () =\u0026gt; { const { getByText } = render( \u0026lt;Button class={testClass} text={sampleText} /\u0026gt; ); const btn = getByText(sampleText); expect(btn).toBeInTheDocument(); }); }); Back to top Integration Testing Next, we look at the FormField component, which uses the FormInput and TextArea components. The component is expected to output the FormInput element by default, and only the TextArea component if its prop \u0026ldquo;type\u0026rdquo; is set to \u0026ldquo;textarea\u0026rdquo;. We also expect the input fields to be disabled as required.\nconst dummyOnChange = (ev: React.FormEvent) =\u0026gt; { return; }; const generateEl = (isDisabled: boolean, type = \u0026#34;text\u0026#34;) =\u0026gt; { return ( \u0026lt;FormField labelContent=\u0026#34;formfield label\u0026#34; onChange={dummyOnChange} disabled={isDisabled} type={type} /\u0026gt; ); }; describe(\u0026#34;Form field component\u0026#34;, () =\u0026gt; { it(\u0026#34;renders label content\u0026#34;, () =\u0026gt; { render(generateEl(false)); const labelEl = screen.getByText(\u0026#34;formfield label\u0026#34;); expect(labelEl).toBeInTheDocument(); }); it(\u0026#34;initial class name is correct\u0026#34;, () =\u0026gt; { render(generateEl(false)); const labelEl = screen.getByText(\u0026#34;formfield label\u0026#34;); expect(labelEl.parentElement).toHaveClass(\u0026#34;form-field\u0026#34;); expect(labelEl).toHaveClass(\u0026#34;form-field__label\u0026#34;); }); it(\u0026#34;renders input element and not textarea\u0026#34;, () =\u0026gt; { render(generateEl(false)); const inputEl = screen.getByRole(\u0026#34;textbox\u0026#34;); expect(inputEl).toBeVisible(); expect(inputEl).toHaveClass(\u0026#34;form-field__input\u0026#34;); expect(inputEl).not.toHaveClass(\u0026#34;form-field__textarea\u0026#34;); }); it(\u0026#34;renders textarea element and not input\u0026#34;, () =\u0026gt; { render(generateEl(false, \u0026#34;textarea\u0026#34;)); const textareaEl = screen.getByRole(\u0026#34;textbox\u0026#34;); expect(textareaEl).toBeVisible(); expect(textareaEl).toHaveClass(\u0026#34;form-field__textarea\u0026#34;); expect(textareaEl).not.toHaveClass(\u0026#34;form-field__input\u0026#34;); }); }); Back to top User Acceptance Testing All commits are merged to the dev branch for user acceptance testing, before they are merged to production. This allows us to always have a production-ready frontend, which will not be hindered by development and possible bugs which can be squashed in time.\nBackend Overview The backend implements Unit Testing locally, regression testing using Github Actions and User Acceptance Testing (System testing) by staging changes on a UAT environment. Testing is executing using golang\u0026rsquo;s built-in testing command, go test \u0026lt;files\u0026gt;.\nUnit Testing Unit testing is done extensively on backend functions. For brevity, we highlight 3 notable unit testing methods that we have implemented in our Backend testing workflow.\nExample 1: Data Mocking - Data Preprocessing Preprocessing of HTTP requests is done for the POST \u0026amp; PATCH requests. In the unit test, we load mock data that are designed to PASS (data with no issue) or FAIL (handle the problematic data by returning an appropriate response).\nWe test for correctness by running each of the valid/invalid mock items in the data preprocessing function. We then check if the expected output matches what we expect.\nBack to top In this case, our pre-processing function ParseFoundItemBody returns a tuple (bytes, error). We check if an error was appropriately detected by the function.\nValid Lost Item Testcases (Truncated) [ { \u0026#34;Name\u0026#34;: \u0026#34;Water bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-05-26T08:51:48.782Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;UTown Bus Stop\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Bottles\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, Yellow, Red\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;@FindNUS\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;LiNe\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;Laptop\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-01-19T01:32:06Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Techno Edge\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Electronics\u0026#34;, }, { \u0026#34;Name\u0026#34;: \u0026#34;Mouse\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-04-16T20:02:30Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Central Library\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Electronics\u0026#34;, }, { \u0026#34;Name\u0026#34;: \u0026#34;Tux\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-03-27T10:08:26Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;COM2 Bus Stop\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Etc\u0026#34;, \u0026#34;Image_base64\u0026#34;: \u0026#34;iVBORw\u0026#34; } ] Back to top Invalid Lost Item Testcases The reason for \u0026lsquo;invalidness\u0026rsquo; of the data is tagged by its name.\n[ { \u0026#34;Name\u0026#34;: \u0026#34;No Date\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Kent Ridge MRT\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Electronics\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;No Location\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-01-31T01:42:30Z\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Electronics\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;No Category\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-01-31T01:42:30Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Kent Ridge MRT\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png\u0026#34; }, { \u0026#34;Date\u0026#34;: \u0026#34;2022-01-31T01:42:30Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;No Name\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Electronics\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;Invalid Date\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;201:42:30Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Kent Ridge MRT\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Electronics\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;Invalid Category\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-01-31T01:42:30Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Kent Ridge MRT\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png\u0026#34; } ] This is the testing code used to test for correctness. We can run this locally using golang\u0026rsquo;s built-in testing function: go test ..\nfunc TestParseFoundItemBody(t *testing.T) { testdata := loadTestItems(\u0026#34;valid_found_items.json\u0026#34;) for _, item := range testdata { bytes, _ := json.Marshal(item) if _, err := ParseFoundItemBody(bytes); err != nil { t.Log(\u0026#34;Found item wrongly flagged as invalid: \u0026#34;, item) t.Log(\u0026#34;Error: \u0026#34;, err.Error()) t.Fail() } } testdata = loadTestItems(\u0026#34;invalid_found_items.json\u0026#34;) for _, item := range testdata { bytes, _ := json.Marshal(item) if _, err := ParseFoundItemBody(bytes); err == nil { t.Log(\u0026#34;Found item wrongly flagged as valid: \u0026#34;, item) t.Log(err.Error()) t.Fail() } } } func TestParseLostItemBody(t *testing.T) { testdata := loadTestItems(\u0026#34;valid_lost_items.json\u0026#34;) for _, item := range testdata { bytes, _ := json.Marshal(item) if _, err := ParseLostItemBody(bytes); err != nil { t.Log(\u0026#34;Lost item wrongly flagged as invalid: \u0026#34;, item) t.Log(err.Error()) t.Fail() } } testdata = loadTestItems(\u0026#34;invalid_lost_items.json\u0026#34;) for _, item := range testdata { bytes, _ := json.Marshal(item) if _, err := ParseLostItemBody(bytes); err == nil { t.Log(\u0026#34;Lost item wrongly flagged as valid: \u0026#34;, item) t.Log(err.Error()) t.Fail() } } } Back to top Example 2: HTTP Request Mocking - Testing Route Handlers Testing of business-critical HTTP routes is important to ensure correctness of the backend solution We can do this by mocking HTTP data via the httptest standard library in golang. These mock requests can be tested against our hanlders to check for expected outputs.\nIn this snippet, we mock HTTP requests with common endpoint errors, such as wrong parameter types being input into the code. We test that the response code is appropriately returned (400 instead of 200), which means that the error was handled correctly internally.\nfunc TestHandleNewLostItem(t *testing.T) { // Test that user_id guard works httpwriter := httptest.NewRecorder() ginContext, _ := gin.CreateTestContext(httpwriter) body := map[string]interface{}{ \u0026#34;Name\u0026#34;: \u0026#34;Laptop\u0026#34;, \u0026#34;Date\u0026#34;: time.Now(), \u0026#34;Location\u0026#34;: \u0026#34;Unknown\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, } bodybytes, _ := json.Marshal(body) ginContext.Request, _ = http.NewRequest(\u0026#34;POST\u0026#34;, \u0026#34;\u0026#34;, bytes.NewBuffer(bodybytes)) HandleNewLostItem(ginContext, nil) if httpwriter.Code != 400 { t.Fatalf(\u0026#34;Wrong code\u0026#34;) } // Test type-senstive Category guard httpwriter = httptest.NewRecorder() ginContext, _ = gin.CreateTestContext(httpwriter) body = map[string]interface{}{ \u0026#34;Name\u0026#34;: \u0026#34;Laptop\u0026#34;, \u0026#34;Date\u0026#34;: time.Now(), \u0026#34;Location\u0026#34;: \u0026#34;Unknown\u0026#34;, \u0026#34;Category\u0026#34;: 77, \u0026#34;User_id\u0026#34;: \u0026#34;7j0fs\u0026#34;, } bodybytes, _ = json.Marshal(body) ginContext.Request, _ = http.NewRequest(\u0026#34;POST\u0026#34;, \u0026#34;\u0026#34;, bytes.NewBuffer(bodybytes)) HandleNewLostItem(ginContext, nil) if httpwriter.Code != 400 { t.Fatalf(\u0026#34;Wrong code - Assertion type\u0026#34;) } } Back to top Example 3: Load Testing: High Concurrency Test Our message queue logic uses some concurrent/parallel programming techniques to achieve high speed. However, this sort of programming can cause a race condition which can be fatal to the backend running or cause very hard to debug bugs.\nIn this example, we showcase our testing logic to detect concurrency bugs by simulating very high load conditions on the function. We test that our unique, incremental id generator GetJobId will guarantee that no matter how many concurrent calls are made to it, ALL ids generated by the function are unique.\nThis is done by calling the function concurrently and doing a counting sort of the JobIds returned.\n// Ensure that concurrent Read-Write for JobId is unique func TestGetJobId(t *testing.T) { const numTest = 100 ch := make(chan uint64, numTest) rand.Seed(time.Now().Unix()) for i := 1; i \u0026lt;= numTest; i++ { // Concurrently launch GetJobIds calls go func() { n := rand.Intn(10) time.Sleep(time.Duration(n) * time.Microsecond) id := GetJobId() ch \u0026lt;- id }() } get := 1 // Store the values in a counting sort array var countSort [numTest + 1]uint64 // Get the returned JobId values for val := range ch { countSort[val]++ get++ // Last value obtained - close the channel to break from the loop if get \u0026gt; numTest { close(ch) } } // Check for duplicates for _, res := range countSort { if res \u0026gt; 1 { t.Errorf(\u0026#34;Duplicate found\u0026#34;) } } } Back to top Regression Testing Regression testing is a software testing practice that ensures an application still functions as expected after any code changes, updates, or improvements.\nWhen we submit Pull Requests to the UAT and Production branches, a regression test is performed. All tests that we wrote to change a microservice are re-run to ensure that a change to one portion of the microservice does not affect the rest of the microservice.\nBack to top User Acceptance Testing We set up a staging environment: User Acceptance Testing (UAT) that is essentially a clone of the production website, but with new features being deployed there for testing. There, we test end-to-end, with the UAT frontend site calling the UAT backend and testing for bugs and expected behaviour.\nBack to top "},{"id":3,"href":"/ms2/technical/frontend/","title":"Frontend Technical Documentation","parent":"Technical Documentation","content":"\nTable of Contents Overview Getting Started Installation Configuration Launch the app Tech Stack Frontend Design Identity Styles Colours Architecture Overview Routing Design Choices Component Tree App Routing Features Home Page Viewing Items Item Submission User Authentication Dashboard Continuous Integration/Continuous Delivery Footnotes Overview [Demo] [Docs]\nFindNUS is a lost and found item management system which aims to supplement existing NUS lost and found system in National University of Singapore (NUS) by reducing the barriers for item finders to submit an item online. As such, item losters are more likely to find an item which they have lost on top of items which only make it to the security personnel. The frontend is built using React 17 and TypeScript, with emphasis on Redux for state management. Sass is also used as the CSS-preprocessor for easier management of styling.\nBack to top Getting Started A demo of this application can be accessed at https://findnus.netlify.app\nThe demo backend is available at https://findnus.herokuapp.com\nFor more information and documentation, please visit https://findnus.github.io/\nInstallation git clone https://github.com/FindNUS/frontend.git cd frontend npm install Configuration Make a copy of .env.example and rename it as .env\nConfigure the project in the .env file by setting the parameters corresponding to your firebase project, and the path to API\nNote: The backend setup must be linked to the same firebase project\nLaunch the app Run npm start to initialise the local server Back to top Tech Stack Back to top Frontend Design Identity Logo Type Description Image Main Logo (Green/Red) For use with light backgrounds Main Logo (White/Red) For use with non-white backgrounds Compressed Logo - Compressed Logo with Backing Also used as favicon Styles Font: Dosis (https://fonts.google.com/specimen/Dosis)\nIcons: Material Icons (https://fonts.google.com/icons)\nColours Christmas Green (#135A60) Christmas Red (A52C49) Gold (#C9A27C) White (#FFFFFF) Back to top Architecture Overview Routing Design Choices React was chosen as the frontend framework to build a single-page application, which helps reduce the loading time between pages, while reducing bandwidth as same resources are not loaded across multiple pages1.\nRedux was chosen to aid in state management, which can not only ensure immutable and predictable states2, but also help us to avoid lifting states through multiple components3, especially ones which do not require the state, giving us cleaner and manageable code.\nTypeScript allows us to catch errors both during development and compilation. As JavaScript being an interpreted language, type errors are likely to surface at the production stage, due to the use of loosely defined, and possibly undefined types. TypeScript enforces static typing, and performs null checking, which helps with early bug detection and saves time wasted on debugging later4.\nPrettier is used as the code formatter to ensure consistent formatting across different workspaces. It also allows for customised formatting which helps various coders better understand one another’s code.\nSass, a CSS pre-processor assists with writing more efficient styling. The Sass code formatting allows the coder to better manage various styles using the Block-Element-Modifier (BEM) naming convention5. This standardises the naming conventions, providing us with structured CSS and ensuring code maintainability in the long term.\nESLint catches and raises common errors in ECMAScript code. This helps us to reduce the use of bad practices, while writing more efficient and less redundant code.\nComponent Tree (To be updated)\nApp Routing Route Page Remarks / Main page /submit-item/type Select submit item type Submit either lost or found item /submit-item/form Form to submit item Query type=lost requires authentication /view View detailed information about item Redirects from home, search and dashboard /login User authentication /dashboard/profile User profile Requires authentication /dashboard/items User-uploaded items Requires authentication /components Overview of components used For development use Back to top Features Home Page Back to top Viewing Items Search View recent items View item details Filter results by category Back to top Item Submission Item type selection Item submission form Back to top User Authentication Main page Login reCAPTCHA Error message display Back to top Dashboard User profile\nUser-uploaded items\nBack to top Continuous Integration/Continuous Delivery Changes to the application are continuously tested with GitHub Actions and Netlify to ensure code functionality. For more information, refer to software engineering and unit testing\nBack to top Footnotes https://www.netsolutions.com/insights/single-page-application/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://redux.js.org/introduction/getting-started\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://redux.js.org/faq/general#when-should-i-use-redux\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://radixweb.com/blog/typescript-vs-javascript#advantages\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://en.bem.info/methodology/naming-convention/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":4,"href":"/ms2/technical/integration/","title":"Integrated Technical Documentation","parent":"Technical Documentation","content":""},{"id":5,"href":"/ms1/","title":"Milestone 1 Documentation","parent":"","content":" Milestone 1 Links Milestone 1 README Milestone 1 Project Log Milestone 1 Poster Milestone 1 Video "},{"id":6,"href":"/ms2/","title":"Milestone 2 README","parent":"","content":"This is the docusite for FindNUS Milestone 2 (Orbital).\nWe arranged and tagged (the feedback question number) in this README to fit closely to the evaluation form, for your convenience.\nTable of Contents Table of Contents Important Milestone 2 Links Poster Video Project Log 1. Acceptance Testing Featureset 2. Features for Milestone 3 3. UIUX and Testing 4.3 Technical Documentation 4.5 Software Engineering Practices Important Milestone 2 Links Poster Video Project Log 1. Acceptance Testing Please head over to the FindNUS live site to test the site out!\nFeatureset This are the core features we have implemented and tested in Milestone 2.\nStupidly Easy Searching Typo-resistant\ne.g. \u0026ldquo;Water bottle\u0026rdquo; and \u0026ldquo;W4tr botl\u0026rdquo; will return the correct item Human Querying\nNo need to specify Category = Cards and fumble around with filters. Typing in anything will return relevant results, similar to Google search. Item peeking on home page (view recently submitted items by descending date) Item filtering by category for both searching and peek User dashboard: View user-uploaded (lost) items, profile Item submission logic (both found and lost items): Drag and drop to upload image, dropdown menu to select various fields Form field validation for item Existing Milestone 1 features\nSMS login App routing Protected routing 2. Features for Milestone 3 You can find the planned featureset here.\n3. UIUX and Testing We document user testing and code testing here.\n4.3 Technical Documentation We document our key technologies and intergration here.\n4.5 Software Engineering Practices We document our SWE practices here.\n"},{"id":7,"href":"/ms2/ms3/","title":"Milestone 3 - Future Features","parent":"Milestone 2 README","content":"This page documents our planned extension features to be done for Milestone 3.\nFrontend User experience Responsive page design for use with mobile and tablet SMS/Email (un)subscription for backend lookout service Geocoding Implement geocoding with Google Maps API, which translates user input into GPS coordinates Integrate map into application and allow user to view item location and get directions Application Testing Extend unit and integration testing to cover all components and pages End-to-end testing with Puppeteer to simulate user intertaction with application Backend Lookout Microservice When a loster submits a lost item, lookup the found database to see which items potentially match the lost item Asynchronously send a \u0026lsquo;possible match\u0026rsquo; alert to the Lost user Possible utilisation of a NLP library to optimise lookups for more relevant matches Security Hardening Add authentication guards to various priviledged endpoints Simple DDoS mitigation logic Include GPS/Geographical data in Database Schema to assist in Geocoding feature Extended Documentation User guide Developer guide \u0026amp; contribution docs "},{"id":8,"href":"/ms2/swe/","title":"Software Engineering Documentation","parent":"Milestone 2 README","content":" Table of Contents Sprint Code Review Frontend DRY Principle Unit Testing CI/CD Continuous Integration Continuous Delivery Backend API Documentation README: Backend Milestone 2 API Documentation Unit Testing CI/CD Continuous Integration Continuous Delivery Sprint We follow a sprint of two weeks, tracked via Github Projects. This is a snapshot of the three sprints that we have done so far in the project: Code Review During our fortnightly meeting with our mentor, code reviews were done by the mentor and we worked on implementing changes based on the review.\nFrontend DRY Principle We adhere to the Don\u0026rsquo;t Repeat Yourself (DRY) principle, which is highly utilised in React components. This allows us to reduce the possibility of introducing errors, and have more predictable code.\nBack to top Unit Testing We use Jest and React Testing Library to ensure code functionality in our application. For more information, click here.\nBack to top CI/CD Continuous Integration New pushes and pull requests are automatically tested with GitHub Actions\nContinuous Delivery When a pull request is opened to merge to either the production (main) or development (dev) branch, a deploy preview is triggerred and Netlify attempts to build a preview which can be tested by the developer, before the changes are merged into the base branch. If the build fails, new commits can be pushed and the build is triggerred again.\nUpon merging, the target branch is automatically built and deployed.\nBack to top Backend API Documentation README: Backend Milestone 2 API Documentation Good API documentation is good SWE practice for backend. It reduces ambiguity in API usage and is important for knowledge retention for when new developers come and old developers go. This industry standard also makes it possible for computers to know how to interface with the API. We documented the backend API using the OpenAPI3 specification.\nSnippet of how the YAML OpenAPI3 specs look like:\npaths: /item: post: description: | Add new Lost item to be put on Lookout on the database. parameters: - in: header name: Authorization description: Firebase ID token of user required: true schema: type: string example: \u0026#34;Authorization: my-firebase-idToken\u0026#34; requestBody: description: Callback item payload content: \u0026#39;application/json\u0026#39;: schema: $ref: \u0026#34;#/components/schemas/NewItem\u0026#34; responses: \u0026#39;200\u0026#39;: description: Item registered into database \u0026#39;400\u0026#39;: description: Rejected new item into database \u0026#39;401\u0026#39;: description: Firebase credentials not invalid This is not so human readable, so we made use of open source openapi to markdown generator to develop Human-friendly docs.\nBack to top Unit Testing Code testing is covered in depth under the code test section. You can read more about it here.\nCI/CD We leveraged Github Actions and Docker to automate testing and continuously deploy our code.\nThis ensures that code works properly on a proper End to End environment before it goes live to production. Overall, CI/CD is used to (regressively) test code and automate the deployment process to smoothly deploy changes.\nSnippet of all CI/CD workflows in action: Continuous Integration Continuous integration is done whenever a pull request is made to the UAT or Production environments. If a microservice has changes, it will run all available unit tests to ensure that changes in one portion of the microservice did not break everything else.\nExample of Passing Unit Test:\nExample of Failing Unit Test that helped us troubleshoot issues before deploying to a live environment:\nContinuous Delivery Continuous delivery is done by pushing built Docker containers into Heroku\u0026rsquo;s docker registry. Various deployment parameters are configured using github actions, and a synchronised, common runtime is instantiated by building a docker container using dockerfiles\nContinuous Delivery Sample Job\nHeroku logs on deployment Back to top Back to top "},{"id":9,"href":"/ms2/technical/","title":"Technical Documentation","parent":"Milestone 2 README","content":"In this page, we talk about the nitty gritty integration and technical details for FindNUS.\nFrontend Technical Documentation Backend Technical Documentation "},{"id":10,"href":"/ms2/uiux/","title":"UI UX and Testing","parent":"Milestone 2 README","content":"Learn more about FindNUS\u0026rsquo; User and Code testing methodologies.\n3.5 User Testing 3.6 Code Testing "},{"id":11,"href":"/ms2/uiux/usertesting/","title":"User Testing","parent":"UI UX and Testing","content":"The testing of the application can be broken down into functional and non-functional tests\nTable of Contents Functional Testing Unit and Integration Testing Non-functional Testing Usability Testing Documentation Testing Functional Testing Unit and Integration Testing For frontend, we perform unit and integration testing with Jest and React Testing Library. For backend, unit testing is conducted with golang’s built-in testing function: go test .., while integration testing is deployed to the User Acceptance Testing backend. For more information, click here\nBack to top Non-functional Testing Usability Testing To perform usability testing, the tester should to complete the following tasks\nTask Todo Expected Result Search Search for the item \u0026ldquo;iPhone 13\u0026rdquo; and view it User should obtain the following item\nPeek View recently uploaded items User should minimally see these items\nFilter Filter recent items with the category \u0026ldquo;Electronics\u0026rdquo; User should minimally see this item\nSubmit an item Submit a found item of your choice (image is optional) User should see their uploaded item (Possibly requires refresh after redirect) Login Attempt to login using either their own mobile number, an international phone number from this page or the following test account:\nPhone Number: +6511111111 (no spaces)\nOTP: 111111 For the test account, user will see the following information:\nFor other accounts, a different user ID will be displayed Dashboard Items View items uploaded with the test account above User should minimally see this item\nLogout Attempt to logout of the application Redirected to home page with login option Back to top Documentation Testing A sample of the API documentation can be found here, and the deployment can be accessed at https://findnus.herokuapp.com/\nSearch Query Example\nRefer to GET /search for more details.\nTo perform a search query for the item \u0026ldquo;Airpods\u0026rdquo;, you may perform a GET request at the /search endpoint with the following URL: https://findnus.herokuapp.com/search?query=Airpods You should expect to receive the following response:\n[ { \u0026#34;Id\u0026#34;:\u0026#34;62b82df7a5d9182afd9665a0\u0026#34;, \u0026#34;Name\u0026#34;:\u0026#34;Airpods\u0026#34;, \u0026#34;Date\u0026#34;:\u0026#34;2022-05-18T00:00:00Z\u0026#34;, \u0026#34;Location\u0026#34;:\u0026#34;UTown Bus Stop\u0026#34;, \u0026#34;Category\u0026#34;:\u0026#34;Electronics\u0026#34;, \u0026#34;Item_details\u0026#34;:\u0026#34;Please call me if found, thank you!!\u0026#34;, \u0026#34;Image_url\u0026#34;:\u0026#34;https://i.imgur.com/c5MuKsu.jpg\u0026#34; } ] Which is equivalent to the following item\nBack to top "},{"id":12,"href":"/","title":"","parent":"","content":" FindNUS Docusite Welcome to FindNUS! Hello! This is the FindNUS documentation website.\nIf you\u0026rsquo;re here for the live application, click me.\nAim: Why FindNUS? FindNUS was created because we feel that the current Lost and Found system in NUS sucks.\nThe official Lost \u0026amp; Found portal is mobile-unfriendly and suffers from low usage because you can only submit items via NUS Security.\nThe Lost and Found NUS telegram group sucks even more. Its hard to properly find your items in the sea of messages and spam; not to mention the security issues of being in a huge group.\nWe want to change that with FindNUS. FindNUS aims to be super accessible for everyone - the losters and founders. In short, we make it easy to submit items and search for them. A detailed writeup can be found in our Milestone 1 documentation.\nFor Evaluators For Profs, mentors, advisors and peers, here is the Milestone 2 README.\nFor curious onlookers We will be adding a general user guide as part of Milestone 3.\nFor developers We will be adding a technical quickstart document as part of Milestone 3.\n"},{"id":13,"href":"/tags/","title":"Tags","parent":"","content":""}]