[{"id":0,"href":"/ms2/swe/apisample/","title":"Actual FindNUS API for Milestone 2","parent":"Software Engineering Documentation","content":"From this line below, it is the Markdown API documentation that is stored on the working backend repository for developers to reference and use.\nFindNUS_api API documentation for FindNUS backend services. Handles the retrieval, processing and management of Lost Items found in NUS.\nTable of Contents Servers Paths GET /debug/ping GET /debug/checkAuth GET /debug/getDemoItem POST /item PATCH /item GET /item DELETE /item GET /item/peek GET /search Schemas Item MiniItem NewItem DeleteItem PatchItem Category ContactMethod ## Servers URL Description https://findnus.herokuapp.com Production cluster that is hosting the backend services for FindNUS https://uat-findnus.herokuapp.com User-Acceptance Testing cluster environment for testing Paths GET /debug/ping Returns a Hello World equivalent message. Shows that the backend connection works.\nResponses ▶ 200 - A hello world message. Headers No headers specified\ntext/plain Name Type Description Accepted values Response string Any Example message: Hi there, you have reached FindNUS! GET /debug/checkAuth Check with backend if the Firebase token is valid.\nHeaders ▷ Authorization Firebase ID token of user\nName Type In Description Accepted values Authorization (required) string header Firebase ID token of user Any Example \u0026#34;Authorization: my-firebase-idToken\u0026#34; Responses ▶ 200 - Id token is valid Headers No headers specified\n▶ 401 - Id token is invalid Headers No headers specified\nGET /debug/getDemoItem Get a demo item for Milestone 1.\nQuery parameters ▷ name Name of the demoset item to be retrieved\nName Type In Description Accepted values name (required) string query Name of the demoset item to be retrieved Any Responses ▶ 200 - Get request is valid, item is found Headers No headers specified\napplication/json Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any Name (required) string Name of lost/found item Any Date (required) string Date-time where item is lost/found Any Location (required) string Where the item was found Any Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_url string Item's accompanying image link Any User_id string UserID associated to this item. Only applicable for Lookout Items. Any Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgur.com/gallery/RaHyECD\u0026#34;, \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34; } ▶ 404 - Get request is valid, item not found Headers No headers specified\ntext/plain Name Type Description Accepted values Response string Any Example Nothing Found! POST /item Add new Lost item to be put on Lookout on the database.\nHeaders ▷ Authorization Firebase ID token of user\nName Type In Description Accepted values Authorization (required) string header Firebase ID token of user Any Example \u0026#34;Authorization: my-firebase-idToken\u0026#34; Request body application/json Name Type Description Accepted values User_id string Unique User_id generated by firebase to associate a user to a Lookout item. Any Name (required) string Name of new lost/found item Any Date (required) string Date-time where item is lost/found Any Location (required) string Where the item was found Any Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_base64 string Accompanying image of new Lost/Found item, if applicable Any Example (generated) { \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_base64\u0026#34;: \u0026#34;string\u0026#34; } Responses ▶ 200 - Item registered into database Headers No headers specified\n▶ 400 - Rejected new item into database Headers No headers specified\n▶ 401 - Firebase credentials not invalid Headers No headers specified\nPATCH /item Update details of an item on the database.\nHeaders ▷ Authorization Firebase ID token of user\nName Type In Description Accepted values Authorization (required) string header Firebase ID token of user Any Example \u0026#34;Authorization: my-firebase-idToken\u0026#34; Query parameters ▷ Id MongoDB ID of the Item\nName Type In Description Accepted values Id (required) string query MongoDB ID of the Item Any Example \u0026#34;Id=629cc52563533a84f60c4c68\u0026#34; ▷ User_id FindNUS User Id (for lost item lookout requests). Include this to remove from Lost (Lookout) Items collection.\nName Type In Description Accepted values User_id (required) string query FindNUS User Id (for lost item lookout requests). Include this to remove from Lost (Lookout) Items collection.\nAny Example \u0026#34;User_id=196afas7\u0026#34; Request body application/json Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any User_id string Unique User_id generated by firebase to associate a user to a Lookout item. Any Name string Name of new lost/found item Any Date string Date-time where item is lost/found Any Location string Where the item was found Any Category string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_base64 string Updated image of Lost/Found item, if applicable Any Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_base64\u0026#34;: \u0026#34;string\u0026#34; } Responses ▶ 200 - OK Headers No headers specified\n▶ 401 - Firebase credentials not invalid Headers No headers specified\nGET /item Get a particular item\u0026rsquo;s full details\nQuery parameters ▷ Id Item Id reference. Case sensitive.\nName Type In Description Accepted values Id (required) string query Item Id reference. Case sensitive. Any ▷ User_id User_id filter to search for this Id in the LOST collection. Case sensitive.\nName Type In Description Accepted values User_id string query User_id filter to search for this Id in the LOST collection. Case sensitive. Any Responses ▶ 200 - A Lost Item\u0026rsquo;s details Headers No headers specified\napplication/json Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any Name (required) string Name of lost/found item Any Date (required) string Date-time where item is lost/found Any Location (required) string Where the item was found Any Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_url string Item's accompanying image link Any User_id string UserID associated to this item. Only applicable for Lookout Items. Any Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgur.com/gallery/RaHyECD\u0026#34;, \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34; } ▶ 404 - Item not found Headers No headers specified\n▶ 500 - Internal server error. Likely to be a message queue fault. Headers No headers specified\nDELETE /item Remove an item listing on the database.\nHeaders ▷ Authorization Firebase ID token of user\nName Type In Description Accepted values Authorization (required) string header Firebase ID token of user Any Example \u0026#34;Authorization: my-firebase-idToken\u0026#34; Query parameters ▷ Id MongoDB ID of the Item\nName Type In Description Accepted values Id (required) string query MongoDB ID of the Item Any Example \u0026#34;Id=629cc52563533a84f60c4c68\u0026#34; ▷ User_id FindNUS User_Id (for lost item lookout requests). Include this to remove from Lost (Lookout) Items collection. Case sensitive.\nName Type In Description Accepted values User_id string query FindNUS User_Id (for lost item lookout requests). Include this to remove from Lost (Lookout) Items collection. Case sensitive.\nAny Example \u0026#34;User_id=196afas7\u0026#34; Request body application/json Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34; } Responses ▶ 200 - Deletion request received and will be processed if the item exists. Headers No headers specified\n▶ 401 - Firebase credentials not invalid Headers No headers specified\nGET /item/peek Get a list of lost items sorted by date. These items are paginated and filtered by category, if requested. The default returns the latest 20 items, with no category filter.\nQuery parameters ▷ offset Number of items to skip (Case sensitive)\nName Type In Description Accepted values offset integer query Number of items to skip (Case sensitive) Any ▷ limit Number of items to return (Case sensitive)\nName Type In Description Accepted values limit integer query Number of items to return (Case sensitive) Any ▷ category Types of category to filter by. Chain multiple category values to filter by the For example, category=Cards\u0026amp;category=Etc will include results from both Cards and Etc.\nName Type In Description Accepted values category string query Types of category to filter by. Chain multiple category values to filter by the For example, category=Cards\u0026amp;category=Etc will include results from both Cards and Etc.\nAny Responses ▶ 200 - Returns an array of lost items that may be filtered Headers No headers specified\napplication/json Name Type Description Accepted values Response array(object) Any Response.Id (required) string The MongoDB ObjectID associated to this Item Any Response.Name (required) string Name of lost/found item Any Response.Date (required) string Date-time where item is lost/found Any Response.Location (required) string Where the item was found Any Response.Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Response.Image_url string Item's accompanying image link Any Example (generated) [ { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgur.com/gallery/RaHyECD\u0026#34; } ] ▶ 500 - Internal server error. Likely to be a message queue fault. Headers No headers specified\nGET /search Text-based search for an item.\nQuery parameters ▷ query Text query to search for lost items. Can be any arbitrary string - the ElasticSearch engine will attempt to best-match the query. The query will be performed over the FOUND collection\u0026rsquo;s Name, Category, Location and Item Detail fields.\nName Type In Description Accepted values query string query Text query to search for lost items. Can be any arbitrary string - the ElasticSearch engine will attempt to best-match the query. The query will be performed over the FOUND collection's Name, Category, Location and Item Detail fields.\nAny Responses ▶ 200 - Returns an array of Found items that were matched to the query string. Headers No headers specified\napplication/json Name Type Description Accepted values Response array(object) Any Response.Id (required) string The MongoDB ObjectID associated to this Item Any Response.Name (required) string Name of lost/found item Any Response.Date (required) string Date-time where item is lost/found Any Response.Location (required) string Where the item was found Any Response.Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Response.Image_url string Item's accompanying image link Any Example (generated) [ { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgur.com/gallery/RaHyECD\u0026#34; } ] ▶ 500 - Internal server error. Likely to be a message queue fault. Headers No headers specified\nSchemas Item Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any Name (required) string Name of lost/found item Any Date (required) string Date-time where item is lost/found Any Location (required) string Where the item was found Any Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_url string Item's accompanying image link Any User_id string UserID associated to this item. Only applicable for Lookout Items. Any Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgur.com/gallery/RaHyECD\u0026#34;, \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34; } MiniItem Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any Name (required) string Name of lost/found item Any Date (required) string Date-time where item is lost/found Any Location (required) string Where the item was found Any Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Image_url string Item's accompanying image link Any Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgur.com/gallery/RaHyECD\u0026#34; } NewItem Name Type Description Accepted values User_id string Unique User_id generated by firebase to associate a user to a Lookout item. Any Name (required) string Name of new lost/found item Any Date (required) string Date-time where item is lost/found Any Location (required) string Where the item was found Any Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_base64 string Accompanying image of new Lost/Found item, if applicable Any Example (generated) { \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_base64\u0026#34;: \u0026#34;string\u0026#34; } DeleteItem Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34; } PatchItem Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any User_id string Unique User_id generated by firebase to associate a user to a Lookout item. Any Name string Name of new lost/found item Any Date string Date-time where item is lost/found Any Location string Where the item was found Any Category string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_base64 string Updated image of Lost/Found item, if applicable Any Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_base64\u0026#34;: \u0026#34;string\u0026#34; } Category Name Type Description Accepted values Category string Non-case sensitive category name Etc, Cards, Notes, Electronics, Bottles Example (generated) \u0026#34;Etc\u0026#34; ContactMethod Name Type Description Accepted values ContactMethod string Non-case sensitive contact method nus_security, telegram, whatsapp, wechat, line, phone_number Example (generated) \u0026#34;nus_security\u0026#34; "},{"id":1,"href":"/ms2/technical/backend/","title":"Backend Technical Documentation","parent":"Technical Documentation","content":" Table of contents Key Technologies High-Level Overview Integration Details Recieving HTTP requests from frontend Sending messages between microservices Ensuring Thread-safe communication Creating, removing and updating, deleting Items Image storage with Imgur Synchronising the Search Engine Appendix A: Backend Design Choices Architecture: Microservice Platform: Heroku Additional Considerations Database: MongoDB Message Broker: RabbitMQ Search Engine: Elasticsearch Language: Golang Image storage: Imgur In this page, we document:\nThe key technologies used The high-level overview of the Backend The integration details Specifically, this is a deep dive into how the various technologies are interfaced with each other. Why certain technologies?1\nKey Technologies This is a list of the technologies that we have used to build the backend.\nGolang (Language) Gin-gonic (HTTP Router) Docker (Runtime) RabbitMQ (Message Broker)2 Heroku (PaaS) MongoDB (Database) Bonsai ElasticSearch (Search Engine) Firebase (Authentication) Imgur (3rd Party API) High-Level Overview This figure shows how the backend roughly works as a whole unit to provide the backend API for FindNUS\u0026rsquo; business logic. As of Milestone 2, we deployed 2 microservices, backend and item.\nBackend is in charge of routing and item is in charge of CRUD. The next section takes a closer look into HOW the technologies are integrated with each other.\nIntegration Details This section dives deep into how the technology is integrated with one another to produce a cohesive backend. We will explain the integration through events.\nRecieving HTTP requests from frontend Technologies Integrated (TI): Golang, Docker, Heroku\nThe frontend needs things to be done, such as POSTing new items or GETting items from the database. This is done through the backend providing an API using the HTTP.\nThese requests enter Heroku\u0026rsquo;s platform and are forwarded to our Backend microservice. To actually use these requests, integration is needed between our Docker runtime and Heroku\u0026rsquo;s platform.\nHeroku sends HTTP requests through a PORT env variable. We just need to get the port details and we can plug it into our logic to process the http requests.\nSnippet:\nport := os.Getenv(\u0026#34;PORT\u0026#34;) if port == \u0026#34;\u0026#34; { // App is running locally port = \u0026#34;8080\u0026#34; } Using Gin-gonic, we can create a HTTP router to listen to the http requests coming in via PORT. We can also ignore malicious/invalid requests by configuring the Cross-Origin settings.\nSnippet:\nrouter := gin.Default() router.Use( cors.New(cors.Config{ AllowAllOrigins: true, AllowHeaders: []string{\u0026#34;Origin\u0026#34;, \u0026#34;Authorization\u0026#34;, \u0026#34;Content-Type\u0026#34;, \u0026#34;Access-Control-Allow-Headers\u0026#34;}, AllowMethods: []string{\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PATCH\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;OPTIONS\u0026#34;}, AllowCredentials: true, }), ) // ...Additional logic, omitted for brevity // Listen for HTTP requests router.Run(\u0026#34;:\u0026#34; + port) Sending messages between microservices TI: Golang, RabbitMQ\nIn the microservices architecture, business logic is seperated into different runtimes/containers based on function.\nWe will need to pass information between these runtimes, for example, the Backend Microservice needing to get a item\u0026rsquo;s detail from the Item Microservice.\nThe microservices are blocked from using HTTP communication between one another due to Heroku policy. So, instead of HTTP, we need to leverage on a message broker with its own communication protocol, RabbitMQ to coordinate messages between these microservices.\nIn summary, using RabbitMQ, we defined three queues to send our own messages.\nItem Queue q_item\nHandles one-off messages that require no return response, such as POST and DELETE.\nRemote Proceedure Call (RPC)3 Queue q_get_req, q_get_resp\nHandles messages that require a return response, such as GET and search queries.\nThe below image illustrates the communciation pipelines between the 2 microservices using RabbitMQ.\nEnsuring Thread-safe communication In particular, when integrating Golang with RabbitMQ to implement the RPC pattern, each RPC job needs to be given a unique correlation_id to identify which RPC call the request belongs to. This is not implemented by the golang driver provided. So we created our own thread-safe unique correlation_id generator.\nThread safety is needed via sync.Mutex as the HTTP requests are processed in-parallel, so there is a risk that multiple RPC subroutines may have the same correlation_id, which will cause bugs.\nFurther, we DO NOT use randomly generated numbers as there is no guarantee that the randomly generated numbers won\u0026rsquo;t be the same for 2 concurrent RPCs that call the random generator.\nSnippet:\n// JobID Unique Job ID. Overflows are OK type JobId struct { mu sync.Mutex id uint64 } var rpcJobId JobId // Thread-safe jobId implementation func GetJobId() uint64 { // Force one goroutine to access jobId at a time // To prevent a race condition rpcJobId.mu.Lock() defer rpcJobId.mu.Unlock() rpcJobId.id += 1 jobId := rpcJobId.id return jobId } Creating, removing and updating, deleting Items TI: MongoDB, Imgur, Elasticsearch\nThere are many moving parts and integrations in the CRUD logic. So, a diagram explaining one of the processes, POSTing a new item:\nUpdating and deleting items follow a very similar control flow, but is omitted for now due to repetition.\nThe important integration details explained below:\nImage storage with Imgur When a new item is added with a raw base_64 string representing the user-submitted image, we store it on imgur. Imgur returns a deleteHash key for us to delete the image, as well as a link to the stored image. We store the hash and link on a Imgur reference database collection to manage our Imgur links.\nFor delete item operations, the deleteHash is obtained from the Imgur collection to properly dispose of our Imgur image.\nSynchronising the Search Engine Elasticsearch runs its own database store in order to index it properly to provide powerful searching capabilities. This means that we need to sync information between MongoDB and Elasticsearch.\nWe have explored solutions such as industry-tested Logstash and open-source \u0026lsquo;River\u0026rsquo;, but they are either paid or are outdated for our version of Elasticsearch.\nSo, we settled on writing the database synchronisation logic ourselves in order to fully interface MongoDB and ElasticSearch.\nWe wrote equivalent CRUD operations on Elasticsearch for their MongoDB counterpart. If an item needs to be Added/Updated/Removed from MongoDB, a parallel and equivalent operation will be done on Elasticsearch.\nSnippet of a ElasticSearch Item Addition:\n// Handler for Adding Item func ElasticAddItem(item ElasticItem) { // Check for item existence first as a safety catch to avoid redundant (the bad kind) copies if ElasticGetItem(item.Id) != (ElasticItem{}) { // Item already exists! This is likely an update. Delete it and re-add in. // Deletion rather than patching is done due to paywalled API log.Println(\u0026#34;Deleting\u0026#34;) ElasticDeleteItem(item.Id) } res, err := EsClient.Index().Index(IndexName).BodyJson(item).Do(context.Background()) if err != nil { log.Fatal(err) } log.Println(\u0026#34;Add item response:\u0026#34;, res) } Appendix A: Backend Design Choices The following was initially documented with references in Milestone 1. As it is important technical information, it is brought over here for documentation sake. Link to the original document.\nArchitecture: Microservice The backend’s overall function is to provide the front-facing web application a bunch of callable APIs. There are two general architectures to designing backend APIs6. Monolithic – business logic \u0026amp; functionality are compiled to one large application. Microservices – business logic \u0026amp; functions are factored out into logically grouped ‘services’ that are isolated from one another. They and communicate through communication protocols such as HTTP or remote procedure calls (RPC).\nFactor Microservices Monolith Speed of development Needs more initial groundwork to setup the backend infrastructure Scales very fast initially, but is harder to maintain the bigger the project Coupling \u0026amp; Redundancy Each microservice is loosely coupled: They work independently of one another, making it fault tolerant Tightly coupled components: changing something may break the entire app Flexibility Each microservice can be built with completely different languages, dependencies and even tech stacks Very difficult to change the tech stack the deeper the application is in development Feature Scalability Scales well in the long run due to loose coupling of components Diminishing scaling speed due to tight coupling of components Load Scalability Scales horizontally – able to serve more consumers by simply launching more microservice nodes Scales vertically, which is expensive and will cause downtime Testing Each microservice needs to be tested separately, with different scripts End to end testing is easier as it only needs to be done on one application Ultimately, we chose to implement FindNUS using microservices architecture, primarily due to the factors highlighted in green. This is because:\nLoose coupling allows for redundancy. If some feature breaks, it will not take down the whole application with it. It also pinpoints us to the failing service for expedient debugging. This is important for Lost and Found services, which should be up 24/7 and cannot afford downtime.\nIts high flexibility allows us to add various feature without breaking core functionality. For example, adding future features that require drastically different tech-stacks such as Machine-learning powered Lost-and-found matching (Python + TensorFlow) can be added with ease without breaking the core components already in place.\nIts horizontal scalability allows us to scale FindNUS just-in-time based on real-time user load, minimising costs of running computational resources on Heroku and MongoDB.\nPlatform: Heroku To host our services, we needed something to host the backend code. We deliberated between cloud platform (s.a. Heroku, AWS), renting an actual server (s.a. Linode) and going serverless.\nFactor Cloud/PaaS (Heroku) Actual Server (Linode) Serverless (Netlify, AWS Lambda) Load Scalability Easily scalable with built-in load balancers Need to manually handle load balancing and scaling by using tools such as Kubernetes Easily scalable since the API triggers are handled by serverless calls Uptime Always on Always on Slower – tends to require more time due to cold start Cost Bounded to ‘free-tier’ limits Most expensive: restrictive trial period Bounded to number of API calls made (including testing). Security Abstracted away by cloud provider Manual setup needed. Require a sysadmin’s expertise to fully secure it Abstracted away by serverless provider Testing Comes with various free logging service and CICD tools built-in Need to setup all testing tools manually Few (free) tools for testing, logging and debugging available. Harder in nature due to reduced visibility of backend processes Ultimately, PaaS was chosen in favour of renting actual servers or going serverless. PaaS gives us the best middle ground. It provides flexibility to build FindNUS efficiently with high uptime and debugging visibility. Yet, have the more time-consuming and tedious backend groundwork such as security and load balancing abstracted away for us.\nFactor Heroku AWS Firebase Cost Free Forever Most tools only have free trial for 1 year Vast suite of free tools forever, excluding computational resources (Cloud Functions) CPU Hours 1000/mo. 750/mo., 1-year free trial N.A. Among the PaaS providers, Heroku wins out the traditional PaaS go-tos such as Firebase and AWS as it provides us the most CPU hours and is the lowest cost amongst them.\nAdditional Considerations Region Placement: Minimising latency. We had the choice between two regions for Heroku free-tier hosting, the EU and USA. We researched and realised that Heroku is hosted by AWS in Virginia (USA) and Ireland (EU)11. Based on an open cloud pinging service12, we determined that Heroku’s EU/Ireland region is the fastest (Annex D). Hence, we used the EU region and placed all other backend helper services (such as MongoDB Atlas) in the same region (EU/Ireland by AWS) in order to reduce latency between these components.\nDatabase: MongoDB MongoDB is a document-based database system. It stores data primarily via a key-value store. This was chosen in favour of traditional relational databases such as PostgreSQL due to the nature of the Lost and Found (LNF) process. LNF items can be potentially registered in a myriad of ways, from photos to NUS security to even voice recording.\nFlexible schema. MongoDB, being document-based, allows flexible scaling of object schema without breaking the whole table. We can phase in more LNF Item data properties as we scale features without breaking the entire table to allow voice recording, video bubble links, GeoJSON, “isWithNusSecurity” flags and more. This is not doable with SQL.\nEase of use. There is no need for normalization13. This makes obtaining data easier since there is no need to join multiple tables from a normalized SQL database. Every parameter can be accessed straight from a document database.\nSchema: Optimising memory usage. As defined in Annex E, certain fields such as item category are stored as 32-bit integers rather than strings. Internally on the backend, there will be mapping logic converting the integers to and from their associated strings (s.a. 1 -\u0026gt; Cards, 2 -\u0026gt; Umbrella). This is done so to optimise each Item’s memory size. A 32-bit integer (4 bytes) holds less memory space compared to a string with at least 4 characters.\nMessage Broker: RabbitMQ Why do we need a message broker? For some context, in the Heroku environment, individual microservices are wrapped in containers called “Dynos”. These dynos are secured in the network and cannot communicate to one another14 over TCP. Hence, a communication protocol is required to pass information from one microservice container to the other for ‘work’ such as CRUD to be done.\nWe compared between three communication protocols that define how isolated containers can talk to each other: Remote procedure calls (RPC), REST and Message Queueing.\nFactor RPC REST Message Queues (MQ) Heroku Support Possible with RPC-enabling message brokers Impossible, inter-container TCP communication is not allowed Possible Speed Fastest Slower than RPC Slowest Load Stability Less stable Stable Stable Message stability Messages can get lost and is unrecoverable Message loss is recoverable due to TCP handshake protocol Messages are persistent and guaranteed to be delivered Since Heroku does not provide support for REST architecture for inter-container communication, we are forced to use RPC and Message Queuing, which is the recommended way to do so (w.r.t. footnote 12). To use RPC \u0026amp;/or MQ, we need a message broker. We chose CloudAMQP (RabbitMQ) as it has extensive documentation on integration with Heroku20.\nRabbitMQ is flexible – it allows us to use message queues and RPC21. Rather than stick to one communication protocol, we plan to use both RPC and MQ as both protocols are best suited for certain use cases.\nRPC: Searching. RPC is very fast compared to the other protocols. This makes it suitable for short-lived operations that require quick responses, such as searching and autocompletion (Elasticsearch API calls). Even if the message is lost, it is tolerable in the case of autocompletion and just-in-time searching.\nMQ: Database CRUD. There are certain operations that need stability and data persistence. When submitting LNF requests/items, the end-user is likely to only POST the request once and leave the application. We cannot afford the situation where a user submits an item request/registration, but the message gets lost halfway in the backend and the item is not registered in the database. MQs can be configured to guarantee delivery and data persistence22, this adds stability to the CRUD process which is critical to the Lost-and-found process.\nSearch Engine: Elasticsearch Elasticsearch (ES) was chosen as the search engine for our application due to the nature of our LNF item schema. Effective searches for lost items rely heavily on string-based parameters such as its name and item details. Further, the “Item_details” is effectively full text, where the users write a long description of the item which allows for flexibility in registering LNF items. For example, an item detail can be: “the bottle’s handle is broken, and it has a NUS sticker on it”.\nFull-text search. ES was built with text searching in mind23. It is optimised for indexing and searching through large bodies of text, such as the “Item_details” parameter. Although it is entirely possible to use full-text searches on SQL and even MongoDB, it is far simpler and to implement via ES. Most importantly, ES outperforms24 other competitors in querying speed.\nLanguage: Golang Golang is a widely used server-side language. Compared to other languages, we chose Golang for the following reasons:\nGolang is a relatively fast25 server-side language. Easy to use HTTP server library that is concurrent26 by nature. (https://github.com/gin-gonic/gin) Unit-testing is built into the language and is simple to make and run. Image storage: Imgur Images tell a thousand words, which is why we included Images as part of the schema to submit a new item to the LNF database (Annex C). It is easier to identify lost items from pictures than wordy text. However, images take up a lot of space. To estimate storage requirements, we assumed that an average smartphone takes 12MP images which is about 3.6MB28 per photo. Our free-tier MongoDB has a storage limit of 512MB. If we only used it to store images, we can fit approximately 142 images, which is very small.\nThe above estimation discounts the fact that smartphone cameras are getting even more powerful, with the upper limit going as high as 108MP (approx. 30MB/photo). Even if we use lossy compression, the disk space required by photos will still be in the order of megabytes. Hence, we cannot afford to directly store images on our backend servers.\nWe decided to use Imgur as a 3rd party image hosting service to offload the storage needs for FindNUS. This is because it has a generous upload limit of 1250 images per day (52 images per hour) and image URL endpoints are persistent.\nIn Milestone 1, we documented in-depth why we used certain technologies instead of another. Link to the document\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nA message broker is needed to communicate between docker containers. This is a heroku perculiarity as the docker containers cannot talk to each other via HTTP due to security policy. In industry, message brokers are often used to coordinate work as well.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nA RPC is something like a synchronous GET request. It enables two computers in seperate locations to send information to each other. A primer if you are interested\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":2,"href":"/technical/backend/","title":"Backend Technical Documentation","parent":"Technical Documentation","content":" Table of contents Key Technologies High-Level Overview Integration Details Recieving HTTP requests from frontend Sending messages between microservices Ensuring Thread-safe communication Creating, removing and updating, deleting Items Image storage with Imgur Synchronising the Search Engine Smart Lookout Service :star: Examples Appendix A: Backend Design Choices Architecture: Microservice Platform: Heroku Additional Considerations Database: MongoDB Message Broker: RabbitMQ Search Engine: Elasticsearch Language: Golang Image storage: Imgur In this page, we document:\nThe key technologies used The high-level overview of the Backend The integration details Specifically, this is a deep dive into how the various technologies are interfaced with each other. Why certain technologies?1\nKey Technologies This is a list of the technologies that we have used to build the backend.\nGolang (Language) Gin-gonic (HTTP Router) Docker (Runtime) RabbitMQ (Message Broker)2 Heroku (PaaS) MongoDB (Database) Bonsai ElasticSearch (Search Engine) Firebase (Authentication) Imgur (3rd Party API) SMTP (Outlook Email Server) Prose (Golang NLP library) High-Level Overview This figure shows how the backend roughly works as a whole unit to provide the backend API for FindNUS\u0026rsquo; business logic. As of Milestone 2, we deployed 2 microservices, backend and item.\nBackend is in charge of routing and item is in charge of CRUD. The next section takes a closer look into HOW the technologies are integrated with each other.\nIntegration Details This section dives deep into how the technology is integrated with one another to produce a cohesive backend. We will explain the integration through events.\nRecieving HTTP requests from frontend Technologies Integrated (TI): Golang, Docker, Heroku\nThe frontend needs things to be done, such as POSTing new items or GETting items from the database. This is done through the backend providing an API using the HTTP.\nThese requests enter Heroku\u0026rsquo;s platform and are forwarded to our Backend microservice. To actually use these requests, integration is needed between our Docker runtime and Heroku\u0026rsquo;s platform.\nHeroku sends HTTP requests through a PORT env variable. We just need to get the port details and we can plug it into our logic to process the http requests.\nSnippet:\nport := os.Getenv(\u0026#34;PORT\u0026#34;) if port == \u0026#34;\u0026#34; { // App is running locally port = \u0026#34;8080\u0026#34; } Using Gin-gonic, we can create a HTTP router to listen to the http requests coming in via PORT. We can also ignore malicious/invalid requests by configuring the Cross-Origin settings.\nSnippet:\nrouter := gin.Default() router.Use( cors.New(cors.Config{ AllowAllOrigins: true, AllowHeaders: []string{\u0026#34;Origin\u0026#34;, \u0026#34;Authorization\u0026#34;, \u0026#34;Content-Type\u0026#34;, \u0026#34;Access-Control-Allow-Headers\u0026#34;}, AllowMethods: []string{\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PATCH\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;OPTIONS\u0026#34;}, AllowCredentials: true, }), ) // ...Additional logic, omitted for brevity // Listen for HTTP requests router.Run(\u0026#34;:\u0026#34; + port) Sending messages between microservices TI: Golang, RabbitMQ\nIn the microservices architecture, business logic is seperated into different runtimes/containers based on function.\nWe will need to pass information between these runtimes, for example, the Backend Microservice needing to get a item\u0026rsquo;s detail from the Item Microservice.\nThe microservices are blocked from using HTTP communication between one another due to Heroku policy. So, instead of HTTP, we need to leverage on a message broker with its own communication protocol, RabbitMQ to coordinate messages between these microservices.\nIn summary, using RabbitMQ, we defined three queues to send our own messages.\nItem Queue q_item\nHandles one-off messages that require no return response, such as POST and DELETE.\nRemote Proceedure Call (RPC)3 Queue q_get_req, q_get_resp, etc\nHandles messages that require a return response, such as GET and search queries.\nThe below image illustrates the communciation pipelines between the various microservices using RabbitMQ.\nEnsuring Thread-safe communication In particular, when integrating Golang with RabbitMQ to implement the RPC pattern, each RPC job needs to be given a unique correlation_id to identify which RPC call the request belongs to. This is not implemented by the golang driver provided. So we created our own thread-safe unique correlation_id generator.\nThread safety is needed via sync.Mutex as the HTTP requests are processed in-parallel, so there is a risk that multiple RPC subroutines may have the same correlation_id, which will cause bugs.\nFurther, we DO NOT use randomly generated numbers as there is no guarantee that the randomly generated numbers won\u0026rsquo;t be the same for 2 concurrent RPCs that call the random generator.\nSnippet:\n// JobID Unique Job ID. Overflows are OK type JobId struct { mu sync.Mutex id uint64 } var rpcJobId JobId // Thread-safe jobId implementation func GetJobId() uint64 { // Force one goroutine to access jobId at a time // To prevent a race condition rpcJobId.mu.Lock() defer rpcJobId.mu.Unlock() rpcJobId.id += 1 jobId := rpcJobId.id return jobId } Creating, removing and updating, deleting Items TI: MongoDB, Imgur, Elasticsearch\nThere are many moving parts and integrations in the CRUD logic. So, a diagram explaining one of the processes, POSTing a new item:\nUpdating and deleting items follow a very similar control flow, but is omitted for now due to repetition.\nThe important integration details explained below:\nImage storage with Imgur When a new item is added with a raw base_64 string representing the user-submitted image, we store it on imgur. Imgur returns a deleteHash key for us to delete the image, as well as a link to the stored image. We store the hash and link on a Imgur reference database collection to manage our Imgur links.\nFor delete item operations, the deleteHash is obtained from the Imgur collection to properly dispose of our Imgur image.\nSynchronising the Search Engine Elasticsearch runs its own database store in order to index it properly to provide powerful searching capabilities. This means that we need to sync information between MongoDB and Elasticsearch.\nWe have explored solutions such as industry-tested Logstash and open-source \u0026lsquo;River\u0026rsquo;, but they are either paid or are outdated for our version of Elasticsearch.\nSo, we settled on writing the database synchronisation logic ourselves in order to fully interface MongoDB and ElasticSearch.\nWe wrote equivalent CRUD operations on Elasticsearch for their MongoDB counterpart. If an item needs to be Added/Updated/Removed from MongoDB, a parallel and equivalent operation will be done on Elasticsearch.\nSnippet of a ElasticSearch Item Addition:\n// Handler for Adding Item func ElasticAddItem(item ElasticItem) { // Check for item existence first as a safety catch to avoid redundant (the bad kind) copies if ElasticGetItem(item.Id) != (ElasticItem{}) { // Item already exists! This is likely an update. Delete it and re-add in. // Deletion rather than patching is done due to paywalled API log.Println(\u0026#34;Deleting\u0026#34;) ElasticDeleteItem(item.Id) } res, err := EsClient.Index().Index(IndexName).BodyJson(item).Do(context.Background()) if err != nil { log.Fatal(err) } log.Println(\u0026#34;Add item response:\u0026#34;, res) } Smart Lookout Service :star: A \u0026ldquo;Smart Lookout Service\u0026rdquo; was added in Milestone 3 as an edge feature.\nTI: Prose, Elasticsearch, SMTP\nIts function is to help Losters look through the dozens of found items and intelligently find Found items that match the Loster\u0026rsquo;s lost item.\nIt uses Natural Language Processing to convert a Lost Item into a text-searchable query before sending it to a specially tuned ElasticSearch query to find good matches for the Lost item. We are using prose, a NLP library for go.\nA Lost (and found) item\u0026rsquo;s data structure looks like this on MongoDB:\ntype Item struct { Id primitive.ObjectID Name string Date time.Time Location string Category string Contact_method string Contact_details string Item_details string Image_url string User_id string Lookout bool }\tBut how do we use NLP on this schema?\nFirst, we strip away all irrelevant terms that may dirty our search. So, irrelevant things like contact_details and user_id are removed.\ntype Item struct { Name string Location string Category string Item_details string }\tWe then concatenate these fields into a long string, delimited by a fullstop \u0026lsquo;.\u0026rsquo; in order for the NLP tokenizer to recognise the different fields as different sentences.\nitem Item // an item of struct Item we want to process rawString := strings.ToUpper(item.Name) rawString += \u0026#34;. \u0026#34; + item.Category rawString += \u0026#34;. \u0026#34; + item.Item_details rawString += \u0026#34;. \u0026#34; + strings.ToUpper(item.Location) // Force prose to recognise this as an entity We then use prose and feed in our prepared string to process out the keywords. We use prose to identify important features of the string - entities (people, places), nouns and adjectives.\ndoc, _ := prose.NewDocument(rawString) query := \u0026#34;\u0026#34; // Entities hold more weight than descriptive tokens, so add them in as duplicates ents := doc.Entities() for _, ent := range ents { query += \u0026#34; \u0026#34; + ent.Text } toks := doc.Tokens() // Filter for keywords for _, tok := range toks { // Take in all the nouns if tok.Tag == \u0026#34;NN\u0026#34; || tok.Tag == \u0026#34;NNS\u0026#34; || tok.Tag == \u0026#34;NNPS\u0026#34; || tok.Tag == \u0026#34;NNP\u0026#34; { query += \u0026#34; \u0026#34; + tok.Text } else if tok.Tag == \u0026#34;JJ\u0026#34; || tok.Tag == \u0026#34;JJR\u0026#34; { // As well as the adjectives query += \u0026#34; \u0026#34; + tok.Text } } The keywords that we are interested in are Nouns of all forms and adjectives. This is because key identifiers for a Lost and Found item lie in nouns and adjectives.\nExamples Input:\n{ \u0026#34;Name\u0026#34;: \u0026#34;Wireless Mouse\u0026#34;, \u0026#34;User_id\u0026#34;: \u0026#34;19fa21\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-04-16T20:02:30Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Central Library\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Electronics\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;i found a logitech mouse at CLB level 2 in one of the cubicles.\u0026#34; } Output:\nWIRELESS MOUSE CLB WIRELESS MOUSE Electronics logitech mouse CLB level cubicles CENTRAL LIBRARY Input:\n{ \u0026#34;Name\u0026#34;: \u0026#34;Nalgene Water bottle\u0026#34;, \u0026#34;User_id\u0026#34;: \u0026#34;19fa21\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-05-26T08:51:48.782Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Digital Systems Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Bottles\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://upload.wikimedia.org/wikipedia/commons/0/07/Multi-use_water_bottle.JPG\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;I lost my nalgene bottle during peak hour at the lab. The bottle has a sticker on it and it\u0026#39;s handle is broken\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;@FindNUS\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Line\u0026#34; } Output:\nNALGENE WATER BOTTLE Bottles NALGENE WATER BOTTLE Bottles nalgene bottle peak hour lab bottle sticker handle DIGITAL SYSTEMS LAB This processed text is important as it will give us relevant ElasticSearch results. When we ignore common filler words like the, a, I, we are sure that the ElasticSearch results are due to the keywords.\nWith the keyword string, we tune our ElasticSearch query to look for close matches.\nWe make use of combined_fields type of matching, where the query spans across multiple fields. Better matching items (more keyword hits) are given a higher score in the ElasticSearch algorithm.\n// In the ElasticSearch database, the Item data structure is the same as the `Item` struct defined above. mmq := elastic.NewMultiMatchQuery( qry, \u0026#34;Name\u0026#34;, \u0026#34;Location\u0026#34;, \u0026#34;Item_details\u0026#34;, \u0026#34;Category\u0026#34;, ) mmq.Type(\u0026#34;combined_fields\u0026#34;) // Min match 3 clauses, 1 for category, 2 for others // This filters out weakly matching items mmq.MinimumShouldMatch(\u0026#34;3\u0026#34;) mmq.FieldWithBoost(\u0026#34;Name\u0026#34;, 3) // Name matches are more significant mmq.FieldWithBoost(\u0026#34;Item_details\u0026#34;, 2) // Item_detail matches catch \u0026#39;hidden\u0026#39; significant keywords With that, we are able to process Lost Items for their keywords and search for relevant matching Items.\nThis is integrated with the frontend. The frontend calls a /lookout endpoint which triggers our Lookout service and returns relevant matches to the user. This automates the manual process of Losters having to scan through our website (or anywhere else) to search for suitable Found items matches.\nAs a bonus, we also allowed Users to subscribe to this \u0026lsquo;Lookout\u0026rsquo; service via email. This is the checkbox as shown in the image below:\nAppendix A: Backend Design Choices The following was initially documented with references in Milestone 1. As it is important technical information, it is brought over here for documentation sake. Link to the original document.\nArchitecture: Microservice The backend’s overall function is to provide the front-facing web application a bunch of callable APIs. There are two general architectures to designing backend APIs6. Monolithic – business logic \u0026amp; functionality are compiled to one large application. Microservices – business logic \u0026amp; functions are factored out into logically grouped ‘services’ that are isolated from one another. They and communicate through communication protocols such as HTTP or remote procedure calls (RPC).\nFactor Microservices Monolith Speed of development Needs more initial groundwork to setup the backend infrastructure Scales very fast initially, but is harder to maintain the bigger the project Coupling \u0026amp; Redundancy Each microservice is loosely coupled: They work independently of one another, making it fault tolerant Tightly coupled components: changing something may break the entire app Flexibility Each microservice can be built with completely different languages, dependencies and even tech stacks Very difficult to change the tech stack the deeper the application is in development Feature Scalability Scales well in the long run due to loose coupling of components Diminishing scaling speed due to tight coupling of components Load Scalability Scales horizontally – able to serve more consumers by simply launching more microservice nodes Scales vertically, which is expensive and will cause downtime Testing Each microservice needs to be tested separately, with different scripts End to end testing is easier as it only needs to be done on one application Ultimately, we chose to implement FindNUS using microservices architecture, primarily due to the factors highlighted in green. This is because:\nLoose coupling allows for redundancy. If some feature breaks, it will not take down the whole application with it. It also pinpoints us to the failing service for expedient debugging. This is important for Lost and Found services, which should be up 24/7 and cannot afford downtime.\nIts high flexibility allows us to add various feature without breaking core functionality. For example, adding future features that require drastically different tech-stacks such as Machine-learning powered Lost-and-found matching (Python + TensorFlow) can be added with ease without breaking the core components already in place.\nIts horizontal scalability allows us to scale FindNUS just-in-time based on real-time user load, minimising costs of running computational resources on Heroku and MongoDB.\nPlatform: Heroku To host our services, we needed something to host the backend code. We deliberated between cloud platform (s.a. Heroku, AWS), renting an actual server (s.a. Linode) and going serverless.\nFactor Cloud/PaaS (Heroku) Actual Server (Linode) Serverless (Netlify, AWS Lambda) Load Scalability Easily scalable with built-in load balancers Need to manually handle load balancing and scaling by using tools such as Kubernetes Easily scalable since the API triggers are handled by serverless calls Uptime Always on Always on Slower – tends to require more time due to cold start Cost Bounded to ‘free-tier’ limits Most expensive: restrictive trial period Bounded to number of API calls made (including testing). Security Abstracted away by cloud provider Manual setup needed. Require a sysadmin’s expertise to fully secure it Abstracted away by serverless provider Testing Comes with various free logging service and CICD tools built-in Need to setup all testing tools manually Few (free) tools for testing, logging and debugging available. Harder in nature due to reduced visibility of backend processes Ultimately, PaaS was chosen in favour of renting actual servers or going serverless. PaaS gives us the best middle ground. It provides flexibility to build FindNUS efficiently with high uptime and debugging visibility. Yet, have the more time-consuming and tedious backend groundwork such as security and load balancing abstracted away for us.\nFactor Heroku AWS Firebase Cost Free Forever Most tools only have free trial for 1 year Vast suite of free tools forever, excluding computational resources (Cloud Functions) CPU Hours 1000/mo. 750/mo., 1-year free trial N.A. Among the PaaS providers, Heroku wins out the traditional PaaS go-tos such as Firebase and AWS as it provides us the most CPU hours and is the lowest cost amongst them.\nAdditional Considerations Region Placement: Minimising latency. We had the choice between two regions for Heroku free-tier hosting, the EU and USA. We researched and realised that Heroku is hosted by AWS in Virginia (USA) and Ireland (EU)11. Based on an open cloud pinging service12, we determined that Heroku’s EU/Ireland region is the fastest (Annex D). Hence, we used the EU region and placed all other backend helper services (such as MongoDB Atlas) in the same region (EU/Ireland by AWS) in order to reduce latency between these components.\nDatabase: MongoDB MongoDB is a document-based database system. It stores data primarily via a key-value store. This was chosen in favour of traditional relational databases such as PostgreSQL due to the nature of the Lost and Found (LNF) process. LNF items can be potentially registered in a myriad of ways, from photos to NUS security to even voice recording.\nFlexible schema. MongoDB, being document-based, allows flexible scaling of object schema without breaking the whole table. We can phase in more LNF Item data properties as we scale features without breaking the entire table to allow voice recording, video bubble links, GeoJSON, “isWithNusSecurity” flags and more. This is not doable with SQL.\nEase of use. There is no need for normalization13. This makes obtaining data easier since there is no need to join multiple tables from a normalized SQL database. Every parameter can be accessed straight from a document database.\nSchema: Optimising memory usage. As defined in Annex E, certain fields such as item category are stored as 32-bit integers rather than strings. Internally on the backend, there will be mapping logic converting the integers to and from their associated strings (s.a. 1 -\u0026gt; Cards, 2 -\u0026gt; Umbrella). This is done so to optimise each Item’s memory size. A 32-bit integer (4 bytes) holds less memory space compared to a string with at least 4 characters.\nMessage Broker: RabbitMQ Why do we need a message broker? For some context, in the Heroku environment, individual microservices are wrapped in containers called “Dynos”. These dynos are secured in the network and cannot communicate to one another14 over TCP. Hence, a communication protocol is required to pass information from one microservice container to the other for ‘work’ such as CRUD to be done.\nWe compared between three communication protocols that define how isolated containers can talk to each other: Remote procedure calls (RPC), REST and Message Queueing.\nFactor RPC REST Message Queues (MQ) Heroku Support Possible with RPC-enabling message brokers Impossible, inter-container TCP communication is not allowed Possible Speed Fastest Slower than RPC Slowest Load Stability Less stable Stable Stable Message stability Messages can get lost and is unrecoverable Message loss is recoverable due to TCP handshake protocol Messages are persistent and guaranteed to be delivered Since Heroku does not provide support for REST architecture for inter-container communication, we are forced to use RPC and Message Queuing, which is recommended by Heroku. To use RPC \u0026amp;/or MQ, we need a message broker. We chose CloudAMQP (RabbitMQ) as it has extensive documentation on integration with Heroku.\nRabbitMQ is flexible – it allows us to use message queues and RPC. Rather than stick to one communication protocol, we plan to use both RPC and MQ as both protocols are best suited for certain use cases.\nRPC: Searching. RPC is very fast compared to the other protocols. This makes it suitable for short-lived operations that require quick responses, such as searching and autocompletion (Elasticsearch API calls). Even if the message is lost, it is tolerable in the case of autocompletion and just-in-time searching.\nMQ: Database CRUD. There are certain operations that need stability and data persistence. When submitting LNF requests/items, the end-user is likely to only POST the request once and leave the application. We cannot afford the situation where a user submits an item request/registration, but the message gets lost halfway in the backend and the item is not registered in the database. MQs can be configured to guarantee delivery and data persistence, this adds stability to the CRUD process which is critical to the Lost-and-found process.\nSearch Engine: Elasticsearch Elasticsearch (ES) was chosen as the search engine for our application due to the nature of our LNF item schema. Effective searches for lost items rely heavily on string-based parameters such as its name and item details. Further, the “Item_details” is effectively full text, where the users write a long description of the item which allows for flexibility in registering LNF items. For example, an item detail can be: “the bottle’s handle is broken, and it has a NUS sticker on it”.\nFull-text search. ES was built with text searching in mind23. It is optimised for indexing and searching through large bodies of text, such as the “Item_details” parameter. Although it is entirely possible to use full-text searches on SQL and even MongoDB, it is far simpler and to implement via ES. Most importantly, ES outperforms other competitors in querying speed.\nLanguage: Golang Golang is a widely used server-side language. Compared to other languages, we chose Golang for the following reasons:\nGolang is a relatively fast server-side language. Easy to use HTTP server library that is concurrent by nature. (https://github.com/gin-gonic/gin) Unit-testing is built into the language and is simple to make and run. Image storage: Imgur Images tell a thousand words, which is why we included Images as part of the schema to submit a new item to the LNF database (Annex C). It is easier to identify lost items from pictures than wordy text. However, images take up a lot of space. To estimate storage requirements, we assumed that an average smartphone takes 12MP images which is about 3.6MB per photo. Our free-tier MongoDB has a storage limit of 512MB. If we only used it to store images, we can fit approximately 142 images, which is very small.\nThe above estimation discounts the fact that smartphone cameras are getting even more powerful, with the upper limit going as high as 108MP (approx. 30MB/photo). Even if we use lossy compression, the disk space required by photos will still be in the order of megabytes. Hence, we cannot afford to directly store images on our backend servers.\nWe decided to use Imgur as a 3rd party image hosting service to offload the storage needs for FindNUS. This is because it has a generous upload limit of 1250 images per day (52 images per hour) and image URL endpoints are persistent.\nIn Milestone 1, we documented in-depth why we used certain technologies instead of another. Link to the document\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nA message broker is needed to communicate between docker containers. This is a heroku perculiarity as the docker containers cannot talk to each other via HTTP due to security policy. In industry, message brokers are often used to coordinate work as well.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nA RPC is something like a synchronous GET request. It enables two computers in seperate locations to send information to each other. A primer if you are interested\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":3,"href":"/technical/challenges/","title":"Challenges Faced","parent":"Technical Documentation","content":"The development of FindNUS had its fair share of challenges. Things did not always go to plan and we often had to think out of the box to solve these issues. In this page, we document some of the interesting and significant challenges we faced while building FindNUS.\nHeroku Security Breach ElasticSearch Woes Pricing API Paywall Synchronising Logic Database limit Obscure Github Secrets Bug Heroku Security Breach When we embarked on FindNUS, we initially wanted to build our backend using Heroku\u0026rsquo;s add-on CICD tool that integrated with Github. However, unknown to us at the time, Heroku had suffered from a massive security breach that led to code in Github private repositories and OAuth tokens being stolen. (We were not affected directly in the breach as it happened before Orbital went live)\nAs a result, Heroku disabled their Github integrated CICD tooling. We still needed to perform CICD and had to pivot towards other means of doing it. So, we manually set up our CICD pipelines using Docker containers and open-source Github Actions. Fortunately, our custom-built CICD pipeline worked well and achieved our objective of having our code be tested systematically and deployed automatically to Heroku.\nElasticSearch Woes ElasticSearch (ES) is a search engine which is critical to FindNUS, making searches easy and typo-resistant. However, it gave us quite a few headaches when trying to integrate it to our system. These are the challenges we faced:\nPricing The mainstream ES cloud vendor elastic.co\u0026rsquo;s solution is at least USD$95/mo, which is way too expensive for our project in its development stage. We considered self-hosting our elasticsearch instance using RaspberryPis or through another cloud provider, but recognised that latency and database stability will be issues if we did that.\nAfter much research, we found Bonsai ElasticSearch, an ES cloud provider that had a true free-tier. However, Bonsai also proved a challenge to work with.\nAPI Paywall As we experimented with Bonsai\u0026rsquo;s API, we found that certain critical functions were paywalled. For example, if we wanted to update an item, we would normally do this by calling a function UpdateByQuery(...). However, this was paywalled by Bonsai!\nWe worked around these by spoofing equivalent API functions. If we needed to update an item, we would delete the item\u0026rsquo;s instance on our ES database then add the new, updated instance. This is not ideal but the best we could do given our budget and circumstances.\nSynchronising Logic After experimenting with ES, we discovered that we needed a way to synchronise our ES database store with our main MongoDB store. We have explored solutions such as industry-tested Logstash and open-source ‘River’, but they are either paid or are outdated for our version of Elasticsearch. To overcome this, we built our own database synchronisation logic.\nDatabase limit Unlike other Database providers such as MongoDB Atlas, Bonsai only allowed us to have one cluster. This meant that our data cannot be seperated nicely into our Production and UAT environment. We worked around this by creating two indexes (analogous to tables) within the cluster, one for our production and the other for our UAT environment.\nObscure Github Secrets Bug We stored keys and passwords as Github Secrets. Github even helps to redact these secrets in Github Action logs as an added layer of security. This is excellent, until we encountered a subtle bug. Some keys such as RSA certificates, use newlines \\n as part of the formatting. BUT - Github treats newlines as literals, i.e. instead of a newline we get the characters \\ and n.\nAs a result, when we took a RSA key from Github, the certificate formatting was completely messed up. Our Unit Testing caught this bug, telling us that our certificate was invalid.\nFiguring out why was a nightmare: When we printed the certificate on Github actions, it was redacted as you can see in the above picture, making it impossible to debug. When we tried debugging via print logs inside the application, the certificate showed up as expected.\nWe eventually discovered this bug by measuring the length of the key when it is loaded. When the key loads as expected, the length of the key was n = 1704 characters. When we loaded the key from github actions, the length was m = 1732. Where are all the mysterious characters coming from? We suspected that the only character in the RSA certifiate that may produce this spooky behaviour was the newline characters. We then realised that the difference between the characters m - n = 28, and when we counted the number of literal \\n in our key, it was also 28! This indicated to us that Github was treating \\n as literal \\ and n, not a single newline character.\nAt long last, the fix was a simple 1 liner.\nprivate_key, _ := os.LookupEnv(\u0026#34;FIREBASE_KEY\u0026#34;) private_key = strings.ReplaceAll(private_key, \u0026#34;\\\\n\u0026#34;, \u0026#34;\\n\u0026#34;) // the fix "},{"id":4,"href":"/ms2/uiux/unittesting/","title":"Code Testing","parent":"UI UX and Testing","content":" Table of Contents Frontend Overview Unit Testing Integration Testing User Acceptance Testing Backend Overview Unit Testing Example 1: Data Mocking - Data Preprocessing Valid Lost Item Testcases (Truncated) Invalid Lost Item Testcases Example 2: HTTP Request Mocking - Testing Route Handlers Example 3: Load Testing: High Concurrency Test Regression Testing User Acceptance Testing Frontend Overview We perform unit and integration testing with Jest and React Testing Library on the application. For Milestone 2, we focus on testing selected components. Test cases will be expanded for Milestone 3, with more components and end-to-end testing. Using Jest, we are able to use the describe and it functions to perform our tests. This is combined with the render and screen from React Testing Library which acts as a bridge between Jest and the components. The test code is executed with the command npm test.\nBack to top Unit Testing We focus on the trivial case of a button component, which is expected to display content based on its input\ndescribe(\u0026#34;Button component\u0026#34;, () =\u0026gt; { const testClass = \u0026#34;btn btn--primary\u0026#34;; const sampleText = \u0026#34;Lorem ipsum\u0026#34;; it(\u0026#34;has the correct class\u0026#34;, () =\u0026gt; { const { getByText } = render( \u0026lt;Button class={testClass} text={sampleText} /\u0026gt; ); const btn = getByText(sampleText); expect(btn).toHaveClass(testClass); }); it(\u0026#34;text renders properly\u0026#34;, () =\u0026gt; { const { getByText } = render( \u0026lt;Button class={testClass} text={sampleText} /\u0026gt; ); const btn = getByText(sampleText); expect(btn).toBeInTheDocument(); }); }); Back to top Integration Testing Next, we look at the FormField component, which uses the FormInput and TextArea components. The component is expected to output the FormInput element by default, and only the TextArea component if its prop \u0026ldquo;type\u0026rdquo; is set to \u0026ldquo;textarea\u0026rdquo;. We also expect the input fields to be disabled as required.\nconst dummyOnChange = (ev: React.FormEvent) =\u0026gt; { return; }; const generateEl = (isDisabled: boolean, type = \u0026#34;text\u0026#34;) =\u0026gt; { return ( \u0026lt;FormField labelContent=\u0026#34;formfield label\u0026#34; onChange={dummyOnChange} disabled={isDisabled} type={type} /\u0026gt; ); }; describe(\u0026#34;Form field component\u0026#34;, () =\u0026gt; { it(\u0026#34;renders label content\u0026#34;, () =\u0026gt; { render(generateEl(false)); const labelEl = screen.getByText(\u0026#34;formfield label\u0026#34;); expect(labelEl).toBeInTheDocument(); }); it(\u0026#34;initial class name is correct\u0026#34;, () =\u0026gt; { render(generateEl(false)); const labelEl = screen.getByText(\u0026#34;formfield label\u0026#34;); expect(labelEl.parentElement).toHaveClass(\u0026#34;form-field\u0026#34;); expect(labelEl).toHaveClass(\u0026#34;form-field__label\u0026#34;); }); it(\u0026#34;renders input element and not textarea\u0026#34;, () =\u0026gt; { render(generateEl(false)); const inputEl = screen.getByRole(\u0026#34;textbox\u0026#34;); expect(inputEl).toBeVisible(); expect(inputEl).toHaveClass(\u0026#34;form-field__input\u0026#34;); expect(inputEl).not.toHaveClass(\u0026#34;form-field__textarea\u0026#34;); }); it(\u0026#34;renders textarea element and not input\u0026#34;, () =\u0026gt; { render(generateEl(false, \u0026#34;textarea\u0026#34;)); const textareaEl = screen.getByRole(\u0026#34;textbox\u0026#34;); expect(textareaEl).toBeVisible(); expect(textareaEl).toHaveClass(\u0026#34;form-field__textarea\u0026#34;); expect(textareaEl).not.toHaveClass(\u0026#34;form-field__input\u0026#34;); }); }); Back to top User Acceptance Testing All commits are merged to the dev branch for user acceptance testing, before they are merged to production. This allows us to always have a production-ready frontend, which will not be hindered by development and possible bugs which can be squashed in time.\nBackend Overview The backend implements Unit Testing locally, regression testing using Github Actions and User Acceptance Testing (System testing) by staging changes on a UAT environment. Testing is executing using golang\u0026rsquo;s built-in testing command, go test \u0026lt;files\u0026gt;.\nUnit Testing Unit testing is done extensively on backend functions. For brevity, we highlight 3 notable unit testing methods that we have implemented in our Backend testing workflow.\nExample 1: Data Mocking - Data Preprocessing Preprocessing of HTTP requests is done for the POST \u0026amp; PATCH requests. In the unit test, we load mock data that are designed to PASS (data with no issue) or FAIL (handle the problematic data by returning an appropriate response).\nWe test for correctness by running each of the valid/invalid mock items in the data preprocessing function. We then check if the expected output matches what we expect.\nBack to top In this case, our pre-processing function ParseFoundItemBody returns a tuple (bytes, error). We check if an error was appropriately detected by the function.\nValid Lost Item Testcases (Truncated) [ { \u0026#34;Name\u0026#34;: \u0026#34;Water bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-05-26T08:51:48.782Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;UTown Bus Stop\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Bottles\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, Yellow, Red\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;@FindNUS\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;LiNe\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;Laptop\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-01-19T01:32:06Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Techno Edge\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Electronics\u0026#34;, }, { \u0026#34;Name\u0026#34;: \u0026#34;Mouse\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-04-16T20:02:30Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Central Library\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Electronics\u0026#34;, }, { \u0026#34;Name\u0026#34;: \u0026#34;Tux\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-03-27T10:08:26Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;COM2 Bus Stop\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Etc\u0026#34;, \u0026#34;Image_base64\u0026#34;: \u0026#34;iVBORw\u0026#34; } ] Back to top Invalid Lost Item Testcases The reason for \u0026lsquo;invalidness\u0026rsquo; of the data is tagged by its name.\n[ { \u0026#34;Name\u0026#34;: \u0026#34;No Date\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Kent Ridge MRT\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Electronics\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;No Location\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-01-31T01:42:30Z\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Electronics\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;No Category\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-01-31T01:42:30Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Kent Ridge MRT\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png\u0026#34; }, { \u0026#34;Date\u0026#34;: \u0026#34;2022-01-31T01:42:30Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;No Name\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Electronics\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;Invalid Date\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;201:42:30Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Kent Ridge MRT\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Electronics\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;Invalid Category\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-01-31T01:42:30Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Kent Ridge MRT\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png\u0026#34; } ] This is the testing code used to test for correctness. We can run this locally using golang\u0026rsquo;s built-in testing function: go test ..\nfunc TestParseFoundItemBody(t *testing.T) { testdata := loadTestItems(\u0026#34;valid_found_items.json\u0026#34;) for _, item := range testdata { bytes, _ := json.Marshal(item) if _, err := ParseFoundItemBody(bytes); err != nil { t.Log(\u0026#34;Found item wrongly flagged as invalid: \u0026#34;, item) t.Log(\u0026#34;Error: \u0026#34;, err.Error()) t.Fail() } } testdata = loadTestItems(\u0026#34;invalid_found_items.json\u0026#34;) for _, item := range testdata { bytes, _ := json.Marshal(item) if _, err := ParseFoundItemBody(bytes); err == nil { t.Log(\u0026#34;Found item wrongly flagged as valid: \u0026#34;, item) t.Log(err.Error()) t.Fail() } } } func TestParseLostItemBody(t *testing.T) { testdata := loadTestItems(\u0026#34;valid_lost_items.json\u0026#34;) for _, item := range testdata { bytes, _ := json.Marshal(item) if _, err := ParseLostItemBody(bytes); err != nil { t.Log(\u0026#34;Lost item wrongly flagged as invalid: \u0026#34;, item) t.Log(err.Error()) t.Fail() } } testdata = loadTestItems(\u0026#34;invalid_lost_items.json\u0026#34;) for _, item := range testdata { bytes, _ := json.Marshal(item) if _, err := ParseLostItemBody(bytes); err == nil { t.Log(\u0026#34;Lost item wrongly flagged as valid: \u0026#34;, item) t.Log(err.Error()) t.Fail() } } } Back to top Example 2: HTTP Request Mocking - Testing Route Handlers Testing of business-critical HTTP routes is important to ensure correctness of the backend solution We can do this by mocking HTTP data via the httptest standard library in golang. These mock requests can be tested against our hanlders to check for expected outputs.\nIn this snippet, we mock HTTP requests with common endpoint errors, such as wrong parameter types being input into the code. We test that the response code is appropriately returned (400 instead of 200), which means that the error was handled correctly internally.\nfunc TestHandleNewLostItem(t *testing.T) { // Test that user_id guard works httpwriter := httptest.NewRecorder() ginContext, _ := gin.CreateTestContext(httpwriter) body := map[string]interface{}{ \u0026#34;Name\u0026#34;: \u0026#34;Laptop\u0026#34;, \u0026#34;Date\u0026#34;: time.Now(), \u0026#34;Location\u0026#34;: \u0026#34;Unknown\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, } bodybytes, _ := json.Marshal(body) ginContext.Request, _ = http.NewRequest(\u0026#34;POST\u0026#34;, \u0026#34;\u0026#34;, bytes.NewBuffer(bodybytes)) HandleNewLostItem(ginContext, nil) if httpwriter.Code != 400 { t.Fatalf(\u0026#34;Wrong code\u0026#34;) } // Test type-senstive Category guard httpwriter = httptest.NewRecorder() ginContext, _ = gin.CreateTestContext(httpwriter) body = map[string]interface{}{ \u0026#34;Name\u0026#34;: \u0026#34;Laptop\u0026#34;, \u0026#34;Date\u0026#34;: time.Now(), \u0026#34;Location\u0026#34;: \u0026#34;Unknown\u0026#34;, \u0026#34;Category\u0026#34;: 77, \u0026#34;User_id\u0026#34;: \u0026#34;7j0fs\u0026#34;, } bodybytes, _ = json.Marshal(body) ginContext.Request, _ = http.NewRequest(\u0026#34;POST\u0026#34;, \u0026#34;\u0026#34;, bytes.NewBuffer(bodybytes)) HandleNewLostItem(ginContext, nil) if httpwriter.Code != 400 { t.Fatalf(\u0026#34;Wrong code - Assertion type\u0026#34;) } } Back to top Example 3: Load Testing: High Concurrency Test Our message queue logic uses some concurrent/parallel programming techniques to achieve high speed. However, this sort of programming can cause a race condition which can be fatal to the backend running or cause very hard to debug bugs.\nIn this example, we showcase our testing logic to detect concurrency bugs by simulating very high load conditions on the function. We test that our unique, incremental id generator GetJobId will guarantee that no matter how many concurrent calls are made to it, ALL ids generated by the function are unique.\nThis is done by calling the function concurrently and doing a counting sort of the JobIds returned.\n// Ensure that concurrent Read-Write for JobId is unique func TestGetJobId(t *testing.T) { const numTest = 100 ch := make(chan uint64, numTest) rand.Seed(time.Now().Unix()) for i := 1; i \u0026lt;= numTest; i++ { // Concurrently launch GetJobIds calls go func() { n := rand.Intn(10) time.Sleep(time.Duration(n) * time.Microsecond) id := GetJobId() ch \u0026lt;- id }() } get := 1 // Store the values in a counting sort array var countSort [numTest + 1]uint64 // Get the returned JobId values for val := range ch { countSort[val]++ get++ // Last value obtained - close the channel to break from the loop if get \u0026gt; numTest { close(ch) } } // Check for duplicates for _, res := range countSort { if res \u0026gt; 1 { t.Errorf(\u0026#34;Duplicate found\u0026#34;) } } } Back to top Regression Testing Regression testing is a software testing practice that ensures an application still functions as expected after any code changes, updates, or improvements.\nWhen we submit Pull Requests to the UAT and Production branches, a regression test is performed. All tests that we wrote to change a microservice are re-run to ensure that a change to one portion of the microservice does not affect the rest of the microservice.\nBack to top User Acceptance Testing We set up a staging environment: User Acceptance Testing (UAT) that is essentially a clone of the production website, but with new features being deployed there for testing. There, we test end-to-end, with the UAT frontend site calling the UAT backend and testing for bugs and expected behaviour.\nBack to top "},{"id":5,"href":"/technical/unittesting/","title":"Code Testing","parent":"Technical Documentation","content":" Table of Contents Frontend Overview Unit Testing Integration Testing User Acceptance Testing Backend Overview Unit Testing Example 1: Data Mocking - Data Preprocessing Valid Lost Item Testcases (Truncated) Invalid Lost Item Testcases Example 2: HTTP Request Mocking - Testing Route Handlers Example 3: Load Testing: High Concurrency Test Regression Testing User Acceptance Testing Frontend Overview We perform unit and integration testing with Jest and React Testing Library on the application. For Milestone 2, we focus on testing selected components. Test cases will be expanded for Milestone 3, with more components and end-to-end testing. Using Jest, we are able to use the describe and it functions to perform our tests. This is combined with the render and screen from React Testing Library which acts as a bridge between Jest and the components. The test code is executed with the command npm test.\nBack to top Unit Testing We focus on the trivial case of a button component, which is expected to display content based on its input\ndescribe(\u0026#34;Button component\u0026#34;, () =\u0026gt; { const testClass = \u0026#34;btn btn--primary\u0026#34;; const sampleText = \u0026#34;Lorem ipsum\u0026#34;; it(\u0026#34;has the correct class\u0026#34;, () =\u0026gt; { const { getByText } = render( \u0026lt;Button class={testClass} text={sampleText} /\u0026gt; ); const btn = getByText(sampleText); expect(btn).toHaveClass(testClass); }); it(\u0026#34;text renders properly\u0026#34;, () =\u0026gt; { const { getByText } = render( \u0026lt;Button class={testClass} text={sampleText} /\u0026gt; ); const btn = getByText(sampleText); expect(btn).toBeInTheDocument(); }); }); Back to top Integration Testing Next, we look at the FormField component, which uses the FormInput and TextArea components. The component is expected to output the FormInput element by default, and only the TextArea component if its prop \u0026ldquo;type\u0026rdquo; is set to \u0026ldquo;textarea\u0026rdquo;. We also expect the input fields to be disabled as required.\nconst dummyOnChange = (ev: React.FormEvent) =\u0026gt; { return; }; const generateEl = (isDisabled: boolean, type = \u0026#34;text\u0026#34;) =\u0026gt; { return ( \u0026lt;FormField labelContent=\u0026#34;formfield label\u0026#34; onChange={dummyOnChange} disabled={isDisabled} type={type} /\u0026gt; ); }; describe(\u0026#34;Form field component\u0026#34;, () =\u0026gt; { it(\u0026#34;renders label content\u0026#34;, () =\u0026gt; { render(generateEl(false)); const labelEl = screen.getByText(\u0026#34;formfield label\u0026#34;); expect(labelEl).toBeInTheDocument(); }); it(\u0026#34;initial class name is correct\u0026#34;, () =\u0026gt; { render(generateEl(false)); const labelEl = screen.getByText(\u0026#34;formfield label\u0026#34;); expect(labelEl.parentElement).toHaveClass(\u0026#34;form-field\u0026#34;); expect(labelEl).toHaveClass(\u0026#34;form-field__label\u0026#34;); }); it(\u0026#34;renders input element and not textarea\u0026#34;, () =\u0026gt; { render(generateEl(false)); const inputEl = screen.getByRole(\u0026#34;textbox\u0026#34;); expect(inputEl).toBeVisible(); expect(inputEl).toHaveClass(\u0026#34;form-field__input\u0026#34;); expect(inputEl).not.toHaveClass(\u0026#34;form-field__textarea\u0026#34;); }); it(\u0026#34;renders textarea element and not input\u0026#34;, () =\u0026gt; { render(generateEl(false, \u0026#34;textarea\u0026#34;)); const textareaEl = screen.getByRole(\u0026#34;textbox\u0026#34;); expect(textareaEl).toBeVisible(); expect(textareaEl).toHaveClass(\u0026#34;form-field__textarea\u0026#34;); expect(textareaEl).not.toHaveClass(\u0026#34;form-field__input\u0026#34;); }); }); Back to top User Acceptance Testing All commits are merged to the dev branch for user acceptance testing, before they are merged to production. This allows us to always have a production-ready frontend, which will not be hindered by development and possible bugs which can be squashed in time.\nBackend Overview The backend implements Unit Testing locally, regression testing using Github Actions and User Acceptance Testing (System testing) by staging changes on a UAT environment. Testing is executing using golang\u0026rsquo;s built-in testing command, go test \u0026lt;files\u0026gt;.\nUnit Testing Unit testing is done extensively on backend functions. For brevity, we highlight 3 notable unit testing methods that we have implemented in our Backend testing workflow.\nExample 1: Data Mocking - Data Preprocessing Preprocessing of HTTP requests is done for the POST \u0026amp; PATCH requests. In the unit test, we load mock data that are designed to PASS (data with no issue) or FAIL (handle the problematic data by returning an appropriate response).\nWe test for correctness by running each of the valid/invalid mock items in the data preprocessing function. We then check if the expected output matches what we expect.\nBack to top In this case, our pre-processing function ParseFoundItemBody returns a tuple (bytes, error). We check if an error was appropriately detected by the function.\nValid Lost Item Testcases (Truncated) [ { \u0026#34;Name\u0026#34;: \u0026#34;Water bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-05-26T08:51:48.782Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;UTown Bus Stop\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Bottles\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, Yellow, Red\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;@FindNUS\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;LiNe\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;Laptop\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-01-19T01:32:06Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Techno Edge\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Electronics\u0026#34;, }, { \u0026#34;Name\u0026#34;: \u0026#34;Mouse\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-04-16T20:02:30Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Central Library\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Electronics\u0026#34;, }, { \u0026#34;Name\u0026#34;: \u0026#34;Tux\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-03-27T10:08:26Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;COM2 Bus Stop\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Etc\u0026#34;, \u0026#34;Image_base64\u0026#34;: \u0026#34;iVBORw\u0026#34; } ] Back to top Invalid Lost Item Testcases The reason for \u0026lsquo;invalidness\u0026rsquo; of the data is tagged by its name.\n[ { \u0026#34;Name\u0026#34;: \u0026#34;No Date\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Kent Ridge MRT\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Electronics\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;No Location\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-01-31T01:42:30Z\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Electronics\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;No Category\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-01-31T01:42:30Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Kent Ridge MRT\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png\u0026#34; }, { \u0026#34;Date\u0026#34;: \u0026#34;2022-01-31T01:42:30Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;No Name\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Electronics\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;Invalid Date\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;201:42:30Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Kent Ridge MRT\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Electronics\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;Invalid Category\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2022-01-31T01:42:30Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;Kent Ridge MRT\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png\u0026#34; } ] This is the testing code used to test for correctness. We can run this locally using golang\u0026rsquo;s built-in testing function: go test ..\nfunc TestParseFoundItemBody(t *testing.T) { testdata := loadTestItems(\u0026#34;valid_found_items.json\u0026#34;) for _, item := range testdata { bytes, _ := json.Marshal(item) if _, err := ParseFoundItemBody(bytes); err != nil { t.Log(\u0026#34;Found item wrongly flagged as invalid: \u0026#34;, item) t.Log(\u0026#34;Error: \u0026#34;, err.Error()) t.Fail() } } testdata = loadTestItems(\u0026#34;invalid_found_items.json\u0026#34;) for _, item := range testdata { bytes, _ := json.Marshal(item) if _, err := ParseFoundItemBody(bytes); err == nil { t.Log(\u0026#34;Found item wrongly flagged as valid: \u0026#34;, item) t.Log(err.Error()) t.Fail() } } } func TestParseLostItemBody(t *testing.T) { testdata := loadTestItems(\u0026#34;valid_lost_items.json\u0026#34;) for _, item := range testdata { bytes, _ := json.Marshal(item) if _, err := ParseLostItemBody(bytes); err != nil { t.Log(\u0026#34;Lost item wrongly flagged as invalid: \u0026#34;, item) t.Log(err.Error()) t.Fail() } } testdata = loadTestItems(\u0026#34;invalid_lost_items.json\u0026#34;) for _, item := range testdata { bytes, _ := json.Marshal(item) if _, err := ParseLostItemBody(bytes); err == nil { t.Log(\u0026#34;Lost item wrongly flagged as valid: \u0026#34;, item) t.Log(err.Error()) t.Fail() } } } Back to top Example 2: HTTP Request Mocking - Testing Route Handlers Testing of business-critical HTTP routes is important to ensure correctness of the backend solution We can do this by mocking HTTP data via the httptest standard library in golang. These mock requests can be tested against our hanlders to check for expected outputs.\nIn this snippet, we mock HTTP requests with common endpoint errors, such as wrong parameter types being input into the code. We test that the response code is appropriately returned (400 instead of 200), which means that the error was handled correctly internally.\nfunc TestHandleNewLostItem(t *testing.T) { // Test that user_id guard works httpwriter := httptest.NewRecorder() ginContext, _ := gin.CreateTestContext(httpwriter) body := map[string]interface{}{ \u0026#34;Name\u0026#34;: \u0026#34;Laptop\u0026#34;, \u0026#34;Date\u0026#34;: time.Now(), \u0026#34;Location\u0026#34;: \u0026#34;Unknown\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, } bodybytes, _ := json.Marshal(body) ginContext.Request, _ = http.NewRequest(\u0026#34;POST\u0026#34;, \u0026#34;\u0026#34;, bytes.NewBuffer(bodybytes)) HandleNewLostItem(ginContext, nil) if httpwriter.Code != 400 { t.Fatalf(\u0026#34;Wrong code\u0026#34;) } // Test type-senstive Category guard httpwriter = httptest.NewRecorder() ginContext, _ = gin.CreateTestContext(httpwriter) body = map[string]interface{}{ \u0026#34;Name\u0026#34;: \u0026#34;Laptop\u0026#34;, \u0026#34;Date\u0026#34;: time.Now(), \u0026#34;Location\u0026#34;: \u0026#34;Unknown\u0026#34;, \u0026#34;Category\u0026#34;: 77, \u0026#34;User_id\u0026#34;: \u0026#34;7j0fs\u0026#34;, } bodybytes, _ = json.Marshal(body) ginContext.Request, _ = http.NewRequest(\u0026#34;POST\u0026#34;, \u0026#34;\u0026#34;, bytes.NewBuffer(bodybytes)) HandleNewLostItem(ginContext, nil) if httpwriter.Code != 400 { t.Fatalf(\u0026#34;Wrong code - Assertion type\u0026#34;) } } Back to top Example 3: Load Testing: High Concurrency Test Our message queue logic uses some concurrent/parallel programming techniques to achieve high speed. However, this sort of programming can cause a race condition which can be fatal to the backend running or cause very hard to debug bugs.\nIn this example, we showcase our testing logic to detect concurrency bugs by simulating very high load conditions on the function. We test that our unique, incremental id generator GetJobId will guarantee that no matter how many concurrent calls are made to it, ALL ids generated by the function are unique.\nThis is done by calling the function concurrently and doing a counting sort of the JobIds returned.\n// Ensure that concurrent Read-Write for JobId is unique func TestGetJobId(t *testing.T) { const numTest = 100 ch := make(chan uint64, numTest) rand.Seed(time.Now().Unix()) for i := 1; i \u0026lt;= numTest; i++ { // Concurrently launch GetJobIds calls go func() { n := rand.Intn(10) time.Sleep(time.Duration(n) * time.Microsecond) id := GetJobId() ch \u0026lt;- id }() } get := 1 // Store the values in a counting sort array var countSort [numTest + 1]uint64 // Get the returned JobId values for val := range ch { countSort[val]++ get++ // Last value obtained - close the channel to break from the loop if get \u0026gt; numTest { close(ch) } } // Check for duplicates for _, res := range countSort { if res \u0026gt; 1 { t.Errorf(\u0026#34;Duplicate found\u0026#34;) } } } Back to top Regression Testing Regression testing is a software testing practice that ensures an application still functions as expected after any code changes, updates, or improvements.\nWhen we submit Pull Requests to the UAT and Production branches, a regression test is performed. All tests that we wrote to change a microservice are re-run to ensure that a change to one portion of the microservice does not affect the rest of the microservice.\nBack to top User Acceptance Testing We set up a staging environment: User Acceptance Testing (UAT) that is essentially a clone of the production website, but with new features being deployed there for testing. There, we test end-to-end, with the UAT frontend site calling the UAT backend and testing for bugs and expected behaviour.\nBack to top "},{"id":6,"href":"/devguide/","title":"Developer Guide","parent":"","content":" Introduction Frontend Installation Pre-requisite: Node.js Pre-requisite: Firebase CLI Cloning and installing dependencies Configuration Setting up API keys on Google Cloud console Setting up Firebase CLI Setting up the .env file Launch the app Branching Strategy Versioning Backend Installation Guide Pre-requisite: Golang Pre-requisite: Docker Pre-requisite: OpenAPI Generator Setting up the Codebase Installing Golang Microservice Dependencies Building on the RESTful API Unit Testing Secrets Management Pull Request (PR) Etiquette Introduction Want to contribute and work on FindNUS? This is the guide for you.\nThis guide covers how to setup the development environment for the Frontend and Backend respectively.\nFrontend Installation Pre-requisite: Node.js You will need Node.js to be installed to run npm. We recommend the LTS version of Node.js \u0026gt;= 16.13, which can be downloaded here for Windows/MacOS. For installation via package managers, refer to this page instead.\nPre-requisite: Firebase CLI Firebase CLI is required for running tests, or if you wish to make amendments to the Emulator Suite. To install, run the following command:\nnpm install -g firebase-tools Cloning and installing dependencies git clone https://github.com/FindNUS/frontend.git cd frontend npm install Configuration Setting up API keys on Google Cloud console There are two environment variables required for the Google Maps API integration. You will need to set the following configurations in the Google Cloud console under \u0026ldquo;APIs \u0026amp; Services\u0026rdquo; \u0026gt; \u0026ldquo;Credentials\u0026rdquo;\nVariable Name API Restrictions Application Restrictions Website Restrictions REACT_APP_MAPS_EMBED_KEY Maps Embed API HTTP referrers (web sites) example.com/* example.com/*/* REACT_APP_MAPS_GEOCODING_KEY Geocoding API Maps JavaScript API Same as above Same as above Note: It is possible to skip this step and use one API key for both environment variables with no application/website restrictions during development. However we do not recommend this to be done in production to prevent unauthorised use of your API key, as it is accessible by the user (Click here for more information).\nSetting up Firebase CLI An authentication token is required for running tests on the Emulator Suite. You may generate the token with the following command:\nfirebase login:ci Upon logging in to your Google account, you will be provided with an access token in the command line. Store this key as FIREBASE_TOKEN.\nSetting up the .env file Make a copy of .env.example and rename it as .env\nConfigure the project in the .env file by setting the parameters corresponding to your firebase project, the path to API, and the parameters as described above\nDepending on your application environment, REACT_APP_DEPLOY_ENV should be set accordingly to production, development or test.\nNote: The backend setup must be linked to the same firebase project\nLaunch the app Run npm start to initialise the local server Back to top Branching Strategy We follow the Gitflow branching strategy to ensure we always have a production-ready branch (main). All pull requests for feature branches (feature/*) should be merged into the dev branch.\nVersioning We follow the Semantic Versioning 2.0.0 standard when publishing releases.\nBackend Installation Guide Pre-requisite: Golang You need to have golang \u0026gt;=1.18 installed. Install guide for Windows/MacOS.\nInstall via Linux Package Managers or MacOS Brew:\n# This varies based on your package manager $ sudo apt install golang-go Pre-requisite: Docker If you wish to directly build and test the docker microservices for whatever reason, you need to install docker.\nInstall guide for Windows/MacOS.\nInstall via Linux Package Managers or Macos Brew -\u0026gt; This is a more involved process.\nPre-requisite: OpenAPI Generator If you are working on the backend microservice and changing the HTTP endpoints that interfaces with the Frontend, you must download this in order to work on the Backend RESTul API documentation.\n# Assumes you have npm installed npm install -g openapi3-generator Setting up the Codebase Simply clone the project and branch out from dev.\ngit clone https://github.com/FindNUS/backend.git # Switch to the dev branch git branch dev # Create your own branch to work on some feature # Branch naming convention example: feat/CatPicture-Integration-120622 git checkout -b \u0026lt;type\u0026gt;/\u0026lt;descripton\u0026gt;-\u0026lt;date DDMMYY\u0026gt; dev Installing Golang Microservice Dependencies Each microservice is logically separated in /internal/{Microservice Name}.\nIf you are working on, say the item microservice, you need to install item\u0026rsquo;s go package dependecies.\ncd /internal/{Microservice Name} go get . After that, you are free to work on the files in the project and develop on FindNUS\u0026rsquo; backend!\nBuilding on the RESTful API If you are modifying/adding a new endpoint or changing anything that interfaces directly with Frontend, you MUST update the API documentation.\nThe backend API documentation is kept in /api. Edit the documentation via findnus.yaml in accordance to OpenAPI3.0 Specs. Once you are done, build the human-friendly docs via the build script provided under /scripts.\n# Root directory of project cd /scripts bash build_api_docs.sh Unit Testing Where possible, unit test critical functions. This is easily done in golang.\nFor example, to test foo.go, create foo_test.go in the same folder.\nThen, in foo_test.go, prepend the function to be tested with Test.\nTrivial Example:\n// foo.go func Add(x int, y int) int{ return x+y } // foo_test.go func TestAdd(t *testing.T){ x1 := 2 x2 := 40 res := Add(x1, x2) if res != 42 { t.Fail() t.Log(\u0026#34;Expected 42 but got\u0026#34;, res) } } The above is a trivial test case for demonstration purposes. It is not rigorous enough for production You should ideally design your testcases to cover all sorts of edge cases. If you need to use a file to store testcase data, simply make a test directory within internal/{Microservice Name} and store your txt/json/whatever data there. You can get inspiration from some of our actual unit test examples here.\nSecrets Management Secrets are exposed to the Docker container via environment variables.\nIf you are adding features that need secrets such as an API key, ping the maintainer to have it registered under the official findnus email and to be added to the repository secrets list on Github. Update the following files to ensure that the secrets are being passed to the program at Deploy time /.github/workflows/deploy_\u0026lt;microservice\u0026gt;.yml /.github/workflows/test_\u0026lt;microservice\u0026gt;.yml /build/\u0026lt;microservice\u0026gt;.Dockerfile Secrets should NEVER be exposed as plaintext in your code. If you need to test locally, consider creating a secrets folder that is added to the .gitignore to store the confidential information that can be loaded on demand. A boilerplate example used in our live codebase:\nsomeSecret := os.Getenv(\u0026#34;SOME_SECRET\u0026#34;) var err error if someSecret == \u0026#34;\u0026#34; { // Read from secrets file f, err := os.Open(\u0026#34;../../secrets/someSecret.txt\u0026#34;) if err != nil { log.Fatal(err) } scanner := bufio.NewScanner(f) defer f.Close() for scanner.Scan() { someSecret = scanner.Text() } } Pull Request (PR) Etiquette We follow a strict PR flow to ensure changes do not break FindNUS backend.\nWe compile all experimental/fresh changes into the dev branch The dev branch is put through regression unit testing. Once passed, it is PR-ed into UAT (staging) environment for system testing The UAT environment, once tested will be merged with main as a release PR into UAT and MAIN will be done by key appointment holders/maintainers as they involve Heroku deployment checking and debugging. For all other purposes, when you PR into dev, you will be subject to a Unit Test of your code as well as a code review by the maintainer before it gets accepted into dev.\n\u0026lt;feat\u0026gt;/\u0026lt;name\u0026gt;-\u0026lt;date\u0026gt; -\u0026gt; dev -\u0026gt; uat -\u0026gt; main\nYour PR should be descriptive and have a detailed changelog, referencing issues where appropriate.\n"},{"id":7,"href":"/technical/swe/apisample/","title":"FindNUS Backend API as of Milestone 3","parent":"Software Engineering Documentation","content":" Foreword This is a copy of the backend api that is being actively refered to by the team to . A human-friendly markdown document was generated from an OpenAPI yaml specs document using OpenAPI-3 Generator.\nAPI documentation for FindNUS backend services. Handles the retrieval, processing and management of Lost Items found in NUS. Comes with additional spicy features like NLP and elasticsearch.\nTable of Contents Servers Paths GET /debug/ping GET /debug/checkAuth GET /debug/getDemoItem POST /item PATCH /item GET /item DELETE /item GET /item/peek GET /search GET /lookout Schemas Item MiniItem NewItem DeleteItem PatchItem Category ContactMethod Servers URL Description https://findnus.herokuapp.com Production cluster that is hosting the backend services for FindNUS https://uat-findnus.herokuapp.com User-Acceptance Testing cluster environment for testing Paths GET /debug/ping Returns a Hello World equivalent message. Shows that the backend connection works.\nResponses ▶ 200 - A hello world message. Headers No headers specified\ntext/plain Name Type Description Accepted values Response string Any Example message: Hi there, you have reached FindNUS! GET /debug/checkAuth Check with backend if the Firebase token is valid.\nHeaders ▷ Authorization Firebase ID token of user\nName Type In Description Accepted values Authorization (required) string header Firebase ID token of user Any Example \u0026#34;Authorization: my-firebase-idToken\u0026#34; Responses ▶ 200 - Id token is valid Headers No headers specified\n▶ 401 - Id token is invalid Headers No headers specified\nGET /debug/getDemoItem Get a demo item for Milestone 1.\nQuery parameters ▷ name Name of the demoset item to be retrieved\nName Type In Description Accepted values name (required) string query Name of the demoset item to be retrieved Any Responses ▶ 200 - Get request is valid, item is found Headers No headers specified\napplication/json Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any Name (required) string Name of lost/found item Any Date (required) string Date-time where item is lost/found Any Location (required) string Where the item was found Any Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_url string Item's accompanying image link Any User_id string UserID associated to this item. Only applicable for Lookout Items. Any Lookout boolean Flag determining whether the Lost item has subscribed to the Lookout service. This flag IS REQUIRED.\nAny Pluscode string Pluscode is a string representing the geolocation of a place based on its latitude and longitude. Optional parameter if the lost item is tagged to a particular LAT/LONG\nAny Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgur.com/gallery/RaHyECD\u0026#34;, \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;Lookout\u0026#34;: false, \u0026#34;Pluscode\u0026#34;: \u0026#34;7QXC+CR Singapore\u0026#34; } ▶ 404 - Get request is valid, item not found Headers No headers specified\ntext/plain Name Type Description Accepted values Response string Any Example Nothing Found! POST /item Add new Lost item to be put on Lookout on the database.\nHeaders ▷ Authorization Firebase ID token of user\nName Type In Description Accepted values Authorization (required) string header Firebase ID token of user Any Example \u0026#34;Authorization: my-firebase-idToken\u0026#34; Request body application/json Name Type Description Accepted values User_id string Unique User_id generated by firebase to associate a user to a Lookout item. Any Name (required) string Name of new lost/found item Any Date (required) string Date-time where item is lost/found Any Location (required) string Where the item was found Any Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_base64 string Accompanying image of new Lost/Found item, if applicable Any Lookout boolean Flag determining whether the Lost item has subscribed to the Lookout service. This flag should only exist for Lost items.\nAny Pluscode string Pluscode is a string representing the geolocation of a place based on its latitude and longitude. Optional parameter if the lost item is tagged to a particular LAT/LONG\nAny Example (generated) { \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_base64\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;Lookout\u0026#34;: false, \u0026#34;Pluscode\u0026#34;: \u0026#34;7QXC+CR Singapore\u0026#34; } Responses ▶ 200 - Item registered into database Headers No headers specified\n▶ 400 - Rejected new item into database Headers No headers specified\n▶ 401 - Firebase credentials not invalid Headers No headers specified\nPATCH /item Update details of an item on the database.\nHeaders ▷ Authorization Firebase ID token of user\nName Type In Description Accepted values Authorization (required) string header Firebase ID token of user Any Example \u0026#34;Authorization: my-firebase-idToken\u0026#34; Query parameters ▷ Id MongoDB ID of the Item\nName Type In Description Accepted values Id (required) string query MongoDB ID of the Item Any Example \u0026#34;Id=629cc52563533a84f60c4c68\u0026#34; ▷ User_id FindNUS User Id (for lost item lookout requests). Include this to remove from Lost (Lookout) Items collection.\nName Type In Description Accepted values User_id (required) string query FindNUS User Id (for lost item lookout requests). Include this to remove from Lost (Lookout) Items collection.\nAny Example \u0026#34;User_id=196afas7\u0026#34; Request body application/json Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any User_id string Unique User_id generated by firebase to associate a user to a Lookout item. Any Name string Name of new lost/found item Any Date string Date-time where item is lost/found Any Location string Where the item was found Any Category string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_base64 string Updated image of Lost/Found item, if applicable Any Lookout boolean Flag determining whether the Lost item has subscribed to the Lookout service. This flag should only exist for Lost items.\nAny Pluscode string Pluscode is a string representing the geolocation of a place based on its latitude and longitude. Optional parameter if the lost item is tagged to a particular LAT/LONG\nAny Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_base64\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;Lookout\u0026#34;: false, \u0026#34;Pluscode\u0026#34;: \u0026#34;7QXC+CR Singapore\u0026#34; } Responses ▶ 200 - OK Headers No headers specified\n▶ 401 - Firebase credentials not invalid Headers No headers specified\nGET /item Get a particular item\u0026rsquo;s full details\nQuery parameters ▷ Id Item Id reference. Case sensitive.\nName Type In Description Accepted values Id (required) string query Item Id reference. Case sensitive. Any ▷ User_id User_id filter to search for this Id in the LOST collection. Case sensitive.\nName Type In Description Accepted values User_id string query User_id filter to search for this Id in the LOST collection. Case sensitive. Any Responses ▶ 200 - A Lost Item\u0026rsquo;s details Headers No headers specified\napplication/json Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any Name (required) string Name of lost/found item Any Date (required) string Date-time where item is lost/found Any Location (required) string Where the item was found Any Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_url string Item's accompanying image link Any User_id string UserID associated to this item. Only applicable for Lookout Items. Any Lookout boolean Flag determining whether the Lost item has subscribed to the Lookout service. This flag IS REQUIRED.\nAny Pluscode string Pluscode is a string representing the geolocation of a place based on its latitude and longitude. Optional parameter if the lost item is tagged to a particular LAT/LONG\nAny Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgur.com/gallery/RaHyECD\u0026#34;, \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;Lookout\u0026#34;: false, \u0026#34;Pluscode\u0026#34;: \u0026#34;7QXC+CR Singapore\u0026#34; } ▶ 404 - Item not found Headers No headers specified\n▶ 500 - Internal server error. Likely to be a message queue fault. Headers No headers specified\nDELETE /item Remove an item listing on the database.\nHeaders ▷ Authorization Firebase ID token of user\nName Type In Description Accepted values Authorization (required) string header Firebase ID token of user Any Example \u0026#34;Authorization: my-firebase-idToken\u0026#34; Query parameters ▷ Id MongoDB ID of the Item\nName Type In Description Accepted values Id (required) string query MongoDB ID of the Item Any Example \u0026#34;Id=629cc52563533a84f60c4c68\u0026#34; ▷ User_id FindNUS User_Id (for lost item lookout requests). Include this to remove from Lost (Lookout) Items collection. Case sensitive.\nName Type In Description Accepted values User_id string query FindNUS User_Id (for lost item lookout requests). Include this to remove from Lost (Lookout) Items collection. Case sensitive.\nAny Example \u0026#34;User_id=196afas7\u0026#34; Request body application/json Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34; } Responses ▶ 200 - Deletion request received and will be processed if the item exists. Headers No headers specified\n▶ 401 - Firebase credentials not invalid Headers No headers specified\nGET /item/peek Get a list of lost items sorted by date. These items are paginated and filtered by category, if requested. The default returns the latest 20 items, with no category filter.\nQuery parameters ▷ offset Number of items to skip (Case sensitive)\nName Type In Description Accepted values offset integer query Number of items to skip (Case sensitive) Any ▷ limit Number of items to return (Case sensitive)\nName Type In Description Accepted values limit integer query Number of items to return (Case sensitive) Any ▷ category Types of category to filter by. Chain multiple category values to filter by the For example, category=Cards\u0026amp;category=Etc will include results from both Cards and Etc.\nName Type In Description Accepted values category string query Types of category to filter by. Chain multiple category values to filter by the For example, category=Cards\u0026amp;category=Etc will include results from both Cards and Etc.\nAny ▷ startdate String representation of the start date to filter by. Date should be in ISO format: YYYY-MM-DDThh:mm:ssZ, eg: 2012:12:25T17:33:59Z\nName Type In Description Accepted values startdate string query String representation of the start date to filter by. Date should be in ISO format: YYYY-MM-DDThh:mm:ssZ, eg: 2012:12:25T17:33:59Z\nAny ▷ enddate String representation of the end date to filter by. Date should be in ISO format: YYYY-MM-DDThh:mm:ssZ, eg: 2012:12:25T17:33:59Z\nName Type In Description Accepted values enddate string query String representation of the end date to filter by. Date should be in ISO format: YYYY-MM-DDThh:mm:ssZ, eg: 2012:12:25T17:33:59Z\nAny Responses ▶ 200 - Returns an array of lost items that may be filtered Headers No headers specified\napplication/json Name Type Description Accepted values Response array(object) Any Response.Id (required) string The MongoDB ObjectID associated to this Item Any Response.Name (required) string Name of lost/found item Any Response.Date (required) string Date-time where item is lost/found Any Response.Location (required) string Where the item was found Any Response.Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Response.Image_url string Item's accompanying image link Any Response.Pluscode string Pluscode is a string representing the geolocation of a place based on its latitude and longitude. Optional parameter if the lost item is tagged to a particular LAT/LONG\nAny Example (generated) [ { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgur.com/gallery/RaHyECD\u0026#34;, \u0026#34;Pluscode\u0026#34;: \u0026#34;7QXC+CR Singapore\u0026#34; } ] ▶ 500 - Internal server error. Likely to be a message queue fault. Headers No headers specified\nGET /search Text-based search for an item.\nQuery parameters ▷ query Text query to search for lost items. Can be any arbitrary string - the ElasticSearch engine will attempt to best-match the query. The query will be performed over the FOUND collection\u0026rsquo;s Name, Category, Location and Item Detail fields.\nName Type In Description Accepted values query string query Text query to search for lost items. Can be any arbitrary string - the ElasticSearch engine will attempt to best-match the query. The query will be performed over the FOUND collection's Name, Category, Location and Item Detail fields.\nAny Responses ▶ 200 - Returns an array of Found items that were matched to the query string. Headers No headers specified\napplication/json Name Type Description Accepted values Response array(object) Any Response.Id (required) string The MongoDB ObjectID associated to this Item Any Response.Name (required) string Name of lost/found item Any Response.Date (required) string Date-time where item is lost/found Any Response.Location (required) string Where the item was found Any Response.Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Response.Image_url string Item's accompanying image link Any Response.Pluscode string Pluscode is a string representing the geolocation of a place based on its latitude and longitude. Optional parameter if the lost item is tagged to a particular LAT/LONG\nAny Example (generated) [ { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgur.com/gallery/RaHyECD\u0026#34;, \u0026#34;Pluscode\u0026#34;: \u0026#34;7QXC+CR Singapore\u0026#34; } ] ▶ 500 - Internal server error. Likely to be a message queue fault. Headers No headers specified\nGET /lookout Get a list of found items that FindNUS decides are a good possible match to the lost item queried.\nQuery parameters ▷ Id Id of the lost item\nName Type In Description Accepted values Id integer query Id of the lost item Any ▷ User_id User_id of the lost item\u0026rsquo;s owner\nName Type In Description Accepted values User_id integer query User_id of the lost item's owner Any Responses ▶ 200 - Returns an array of found items that best match the lost item. Headers No headers specified\napplication/json Name Type Description Accepted values Response array(object) Any Response.Id (required) string The MongoDB ObjectID associated to this Item Any Response.Name (required) string Name of lost/found item Any Response.Date (required) string Date-time where item is lost/found Any Response.Location (required) string Where the item was found Any Response.Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Response.Image_url string Item's accompanying image link Any Response.Pluscode string Pluscode is a string representing the geolocation of a place based on its latitude and longitude. Optional parameter if the lost item is tagged to a particular LAT/LONG\nAny Example (generated) [ { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgur.com/gallery/RaHyECD\u0026#34;, \u0026#34;Pluscode\u0026#34;: \u0026#34;7QXC+CR Singapore\u0026#34; } ] ▶ 400 - Bad request. Missing one or both of User_id and id. Headers No headers specified\n▶ 500 - Internal server error. Likely to be a message queue fault. Headers No headers specified\nSchemas Item Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any Name (required) string Name of lost/found item Any Date (required) string Date-time where item is lost/found Any Location (required) string Where the item was found Any Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_url string Item's accompanying image link Any User_id string UserID associated to this item. Only applicable for Lookout Items. Any Lookout boolean Flag determining whether the Lost item has subscribed to the Lookout service. This flag IS REQUIRED.\nAny Pluscode string Pluscode is a string representing the geolocation of a place based on its latitude and longitude. Optional parameter if the lost item is tagged to a particular LAT/LONG\nAny Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgur.com/gallery/RaHyECD\u0026#34;, \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;Lookout\u0026#34;: false, \u0026#34;Pluscode\u0026#34;: \u0026#34;7QXC+CR Singapore\u0026#34; } MiniItem Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any Name (required) string Name of lost/found item Any Date (required) string Date-time where item is lost/found Any Location (required) string Where the item was found Any Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Image_url string Item's accompanying image link Any Pluscode string Pluscode is a string representing the geolocation of a place based on its latitude and longitude. Optional parameter if the lost item is tagged to a particular LAT/LONG\nAny Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Image_url\u0026#34;: \u0026#34;https://imgur.com/gallery/RaHyECD\u0026#34;, \u0026#34;Pluscode\u0026#34;: \u0026#34;7QXC+CR Singapore\u0026#34; } NewItem Name Type Description Accepted values User_id string Unique User_id generated by firebase to associate a user to a Lookout item. Any Name (required) string Name of new lost/found item Any Date (required) string Date-time where item is lost/found Any Location (required) string Where the item was found Any Category (required) string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_base64 string Accompanying image of new Lost/Found item, if applicable Any Lookout boolean Flag determining whether the Lost item has subscribed to the Lookout service. This flag should only exist for Lost items.\nAny Pluscode string Pluscode is a string representing the geolocation of a place based on its latitude and longitude. Optional parameter if the lost item is tagged to a particular LAT/LONG\nAny Example (generated) { \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_base64\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;Lookout\u0026#34;: false, \u0026#34;Pluscode\u0026#34;: \u0026#34;7QXC+CR Singapore\u0026#34; } DeleteItem Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34; } PatchItem Name Type Description Accepted values Id (required) string The MongoDB ObjectID associated to this Item Any User_id string Unique User_id generated by firebase to associate a user to a Lookout item. Any Name string Name of new lost/found item Any Date string Date-time where item is lost/found Any Location string Where the item was found Any Category string Type of item Etc, Cards, Notes, Electronics, Bottles Contact_method string Founder/Lostee Contact Method nus_security, telegram, whatsapp, wechat, line, phone_number Contact_details string Contact details of Founder/Lostee Any Item_details string Any Image_base64 string Updated image of Lost/Found item, if applicable Any Lookout boolean Flag determining whether the Lost item has subscribed to the Lookout service. This flag should only exist for Lost items.\nAny Pluscode string Pluscode is a string representing the geolocation of a place based on its latitude and longitude. Optional parameter if the lost item is tagged to a particular LAT/LONG\nAny Example (generated) { \u0026#34;Id\u0026#34;: \u0026#34;98721yrr0u14oure\u0026#34;, \u0026#34;User_id\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Water Bottle\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;2019-08-24T14:15:22Z\u0026#34;, \u0026#34;Location\u0026#34;: \u0026#34;E4A DSA Lab\u0026#34;, \u0026#34;Category\u0026#34;: \u0026#34;Cards\u0026#34;, \u0026#34;Contact_method\u0026#34;: \u0026#34;Telegram\u0026#34;, \u0026#34;Contact_details\u0026#34;: \u0026#34;FindNUS\u0026#34;, \u0026#34;Item_details\u0026#34;: \u0026#34;Blue, with a sticker and broken handle\u0026#34;, \u0026#34;Image_base64\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;Lookout\u0026#34;: false, \u0026#34;Pluscode\u0026#34;: \u0026#34;7QXC+CR Singapore\u0026#34; } Category Name Type Description Accepted values Category string Non-case sensitive category name Etc, Cards, Notes, Electronics, Bottles Example (generated) \u0026#34;Etc\u0026#34; ContactMethod Name Type Description Accepted values ContactMethod string Non-case sensitive contact method nus_security, telegram, whatsapp, wechat, line, phone_number Example (generated) \u0026#34;nus_security\u0026#34; "},{"id":8,"href":"/ms2/technical/frontend/","title":"Frontend Technical Documentation","parent":"Technical Documentation","content":"\nTable of Contents Overview Getting Started Installation Configuration Launch the app Tech Stack Frontend Design Identity Styles Colours Architecture Overview Routing Design Choices Component Tree App Routing Features Home Page Viewing Items Item Submission User Authentication Dashboard Continuous Integration/Continuous Delivery Footnotes Overview [Demo] [Docs]\nFindNUS is a lost and found item management system which aims to supplement existing NUS lost and found system in National University of Singapore (NUS) by reducing the barriers for item finders to submit an item online. As such, item losters are more likely to find an item which they have lost on top of items which only make it to the security personnel. The frontend is built using React 17 and TypeScript, with emphasis on Redux for state management. Sass is also used as the CSS-preprocessor for easier management of styling.\nBack to top Getting Started A demo of this application can be accessed at https://findnus.netlify.app\nThe demo backend is available at https://findnus.herokuapp.com\nFor more information and documentation, please visit https://findnus.github.io/\nInstallation git clone https://github.com/FindNUS/frontend.git cd frontend npm install Configuration Make a copy of .env.example and rename it as .env\nConfigure the project in the .env file by setting the parameters corresponding to your firebase project, and the path to API\nNote: The backend setup must be linked to the same firebase project\nLaunch the app Run npm start to initialise the local server Back to top Tech Stack Back to top Frontend Design Identity Logo Type Description Image Main Logo (Green/Red) For use with light backgrounds Main Logo (White/Red) For use with non-white backgrounds Compressed Logo - Compressed Logo with Backing Also used as favicon Styles Font: Dosis (https://fonts.google.com/specimen/Dosis)\nIcons: Material Icons (https://fonts.google.com/icons)\nColours Christmas Green (#135A60) Christmas Red (A52C49) Gold (#C9A27C) White (#FFFFFF) Back to top Architecture Overview Routing Design Choices React was chosen as the frontend framework to build a single-page application, which helps reduce the loading time between pages, while reducing bandwidth as same resources are not loaded across multiple pages1.\nRedux was chosen to aid in state management, which can not only ensure immutable and predictable states2, but also help us to avoid lifting states through multiple components3, especially ones which do not require the state, giving us cleaner and manageable code.\nTypeScript allows us to catch errors both during development and compilation. As JavaScript being an interpreted language, type errors are likely to surface at the production stage, due to the use of loosely defined, and possibly undefined types. TypeScript enforces static typing, and performs null checking, which helps with early bug detection and saves time wasted on debugging later4.\nPrettier is used as the code formatter to ensure consistent formatting across different workspaces. It also allows for customised formatting which helps various coders better understand one another’s code.\nSass, a CSS pre-processor assists with writing more efficient styling. The Sass code formatting allows the coder to better manage various styles using the Block-Element-Modifier (BEM) naming convention5. This standardises the naming conventions, providing us with structured CSS and ensuring code maintainability in the long term.\nESLint catches and raises common errors in ECMAScript code. This helps us to reduce the use of bad practices, while writing more efficient and less redundant code.\nComponent Tree (To be updated)\nApp Routing Route Page Remarks / Main page /submit-item/type Select submit item type Submit either lost or found item /submit-item/form Form to submit item Query type=lost requires authentication /view View detailed information about item Redirects from home, search and dashboard /login User authentication /dashboard/profile User profile Requires authentication /dashboard/items User-uploaded items Requires authentication /components Overview of components used For development use Back to top Features Home Page Back to top Viewing Items Search View recent items View item details Filter results by category Back to top Item Submission Item type selection Item submission form Back to top User Authentication Main page Login reCAPTCHA Error message display Back to top Dashboard User profile\nUser-uploaded items\nBack to top Continuous Integration/Continuous Delivery Changes to the application are continuously tested with GitHub Actions and Netlify to ensure code functionality. For more information, refer to software engineering and unit testing\nBack to top Footnotes https://www.netsolutions.com/insights/single-page-application/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://redux.js.org/introduction/getting-started\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://redux.js.org/faq/general#when-should-i-use-redux\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://radixweb.com/blog/typescript-vs-javascript#advantages\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://en.bem.info/methodology/naming-convention/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":9,"href":"/technical/frontend/","title":"Frontend Technical Documentation","parent":"Technical Documentation","content":"\nTable of Contents Overview Getting Started Installation Configuration Launch the app Tech Stack Frontend Design Identity Styles Colours Architecture Overview Routing Design Choices Component Tree App Routing Features Continuous Integration/Continuous Delivery Footnotes Overview [Demo] [Docs]\nFindNUS is a lost and found item management system which aims to supplement existing NUS lost and found system in National University of Singapore (NUS) by reducing the barriers for item finders to submit an item online. As such, item losters are more likely to find an item which they have lost on top of items which only make it to the security personnel. The frontend is built using React 17 and TypeScript, with emphasis on Redux for state management. Sass is also used as the CSS-preprocessor for easier management of styling.\nBack to top Getting Started A demo of this application can be accessed at https://findnus.netlify.app\nThe demo backend is available at https://findnus.herokuapp.com\nFor more information and documentation, please visit https://findnus.github.io/\nInstallation git clone https://github.com/FindNUS/frontend.git cd frontend npm install Configuration Make a copy of .env.example and rename it as .env\nConfigure the project in the .env file by setting the parameters corresponding to your firebase project, and the path to API\nNote: The backend setup must be linked to the same firebase project\nLaunch the app Run npm start to initialise the local server Back to top Tech Stack Back to top Frontend Design Identity Logo Type Description Image Main Logo (Green/Red) For use with light backgrounds Main Logo (White/Red) For use with non-white backgrounds Compressed Logo - Compressed Logo with Backing Also used as favicon Styles Font: Dosis (https://fonts.google.com/specimen/Dosis)\nIcons: Material Icons (https://fonts.google.com/icons)\nColours Christmas Green (#135A60) Christmas Red (A52C49) Gold (#C9A27C) White (#FFFFFF) Back to top Architecture Overview Routing Design Choices React was chosen as the frontend framework to build a single-page application, which helps reduce the loading time between pages, while reducing bandwidth as same resources are not loaded across multiple pages1.\nRedux was chosen to aid in state management, which can not only ensure immutable and predictable states2, but also help us to avoid lifting states through multiple components3, especially ones which do not require the state, giving us cleaner and manageable code.\nTypeScript allows us to catch errors both during development and compilation. As JavaScript being an interpreted language, type errors are likely to surface at the production stage, due to the use of loosely defined, and possibly undefined types. TypeScript enforces static typing, and performs null checking, which helps with early bug detection and saves time wasted on debugging later4.\nPrettier is used as the code formatter to ensure consistent formatting across different workspaces. It also allows for customised formatting which helps various coders better understand one another’s code.\nSass, a CSS pre-processor assists with writing more efficient styling. The Sass code formatting allows the coder to better manage various styles using the Block-Element-Modifier (BEM) naming convention5. This standardises the naming conventions, providing us with structured CSS and ensuring code maintainability in the long term.\nESLint catches and raises common errors in ECMAScript code. This helps us to reduce the use of bad practices, while writing more efficient and less redundant code.\nComponent Tree App Routing Route Page Remarks / Main page /search View search results /view View detailed information about item Redirects from home, search and dashboard /login User authentication /dashboard/profile User profile Requires authentication /dashboard/items User-uploaded items Requires authentication /submit-item/type Select submit item type Submit either lost or found item /submit-item/form Form to submit item Query type=lost requires authentication Back to top Features For more details on our features, click here for more information.\nContinuous Integration/Continuous Delivery Changes to the application are continuously tested with GitHub Actions and Netlify to ensure code functionality. For more information, refer to software engineering and unit testing\nBack to top Footnotes https://www.netsolutions.com/insights/single-page-application/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://redux.js.org/introduction/getting-started\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://redux.js.org/faq/general#when-should-i-use-redux\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://radixweb.com/blog/typescript-vs-javascript#advantages\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://en.bem.info/methodology/naming-convention/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":10,"href":"/ms2/technical/integration/","title":"Integrated Technical Documentation","parent":"Technical Documentation","content":""},{"id":11,"href":"/ms1/","title":"Milestone 1 Documentation","parent":"","content":" Milestone 1 Links Milestone 1 README Milestone 1 Project Log Milestone 1 Poster Milestone 1 Video "},{"id":12,"href":"/ms2/","title":"Milestone 2 README","parent":"","content":"This is the docusite for FindNUS Milestone 2 (Orbital).\nWe arranged and tagged (the feedback question number) in this README to fit closely to the evaluation form, for your convenience.\nTable of Contents Table of Contents Important Milestone 2 Links Poster Video Project Log 1. Acceptance Testing Featureset 2. Features for Milestone 3 3. UIUX and Testing 4.3 Technical Documentation 4.5 Software Engineering Practices Important Milestone 2 Links Poster Video Project Log 1. Acceptance Testing Please head over to the FindNUS live site to test the site out!\nFeatureset This are the core features we have implemented and tested in Milestone 2.\nStupidly Easy Searching Typo-resistant\ne.g. \u0026ldquo;Water bottle\u0026rdquo; and \u0026ldquo;W4tr botl\u0026rdquo; will return the correct item Human Querying\nNo need to specify Category = Cards and fumble around with filters. Typing in anything will return relevant results, similar to Google search. Item peeking on home page (view recently submitted items by descending date) Item filtering by category for both searching and peek User dashboard: View user-uploaded (lost) items, profile Item submission logic (both found and lost items): Drag and drop to upload image, dropdown menu to select various fields Form field validation for item Existing Milestone 1 features\nSMS login App routing Protected routing 2. Features for Milestone 3 You can find the planned featureset here.\n3. UIUX and Testing We document user testing and code testing here.\n4.3 Technical Documentation We document our key technologies and intergration here.\n4.5 Software Engineering Practices We document our SWE practices here.\n"},{"id":13,"href":"/ms2/ms3/","title":"Milestone 3 - Future Features","parent":"Milestone 2 README","content":"This page documents our planned extension features to be done for Milestone 3.\nFrontend User experience Responsive page design for use with mobile and tablet SMS/Email (un)subscription for backend lookout service Geocoding Implement geocoding with Google Maps API, which translates user input into GPS coordinates Integrate map into application and allow user to view item location and get directions Application Testing Extend unit and integration testing to cover all components and pages End-to-end testing with Puppeteer to simulate user intertaction with application Backend Lookout Microservice When a loster submits a lost item, lookup the found database to see which items potentially match the lost item Asynchronously send a \u0026lsquo;possible match\u0026rsquo; alert to the Lost user Possible utilisation of a NLP library to optimise lookups for more relevant matches Security Hardening Add authentication guards to various priviledged endpoints Simple DDoS mitigation logic Include GPS/Geographical data in Database Schema to assist in Geocoding feature Extended Documentation User guide Developer guide \u0026amp; contribution docs "},{"id":14,"href":"/problem/","title":"Problem Research","parent":"","content":" Introduction Motivation User Stories The Founders The TLDR In Detail The Losters The TLDR In Detail Unofficial Groups. NUS Repo App. Competitor Analysis Aim of FindNUS What makes FindNUS different Next: Project Scope Introduction This page documents the Why of FindNUS. We document our motivation, then validate it by investigating the Lost \u0026amp; Found User Stories. We lay out our aim and also look at what\u0026rsquo;s out there currently vs our proposed solution. Finally, we continue with the next steps in our project scope.\nMotivation FindNUS was created because we feel that the current Lost and Found (LNF) system in NUS sucks.\nIt is decentralized and messy. There are 2 primary systems that people who Lose or Find items can approach to register their LNF.\nRepoApp, the official LNF vendor serving NUS The plethora of unofficial telegram groups We felt that these 2 systems don’t put user experience first and are hard to navigate.\nFor example, the RepoApp is underutilised, and the telegram groups are filled with spam, making it hard to properly find your lost item, if it even exists in that group!\nTo confirm our motivation and understand what specifically sucks about the current LNF situation in NUS, we investigated the user story of people who lose their items, Losters, and people who find lost items, Founders.\nUser Stories The Founders The TLDR As someone who found a lost item, I want an easy and flexible way of registering it without having to register for an account. As someone who found a lost item, I am usually en-route and I would not want to go out of my way to pass the item to the security. In Detail This is what we found1 about Founders.\nScenario 1: Founders can go out of their way to bring the item to any Lost and Found reporting points in NUS. These items end up being registered in the official RepoApp listing. This usually does not happen, because it is a hassle to go out of one\u0026rsquo;s way to submit a lost item.\nScenario 2: Founders can hold on to the item and try to contact the owner via unofficial communication channels. This is also a hassle to do, but can be more convenient to the Founder as they have the flexibility of connecting to the Loster via the communication channel (eg. telegram)\nScenario 3: Leave the item where it was found but ping its location via unofficial communication channels. This is usually what happens. A cursory look into one of these groups are full of these scenarios, such as the image below:\nYou can even see for yourself in the actual group here.\nThe Losters The TLDR As someone who lost their item on campus, I want an active and easy-to-use platform to quickly search for my lost items. As someone who lost their item on campus and cannot find it anywhere online, I want to be helped and informed automatically if my item might be found. In Detail If someone loses their things on campus, they can either:\nCheck various unofficial groups such as NUS Lost and Found or Try finding their items on NUS RepoApp. Both have their own sets of problems. Unofficial Groups. There are too many places to check. The Loster must scroll through hundreds of messages in big Lost and Found groups or message various smaller groups such as their house chat to ask around for their lost item. To the Loster, it is overwhelming to keep track of everything and frustrating to have to comb through so many groups and messages.\nNUS Repo App. What about the official platform? Items listed on RepoApp may suffer from survivorship bias. Only items that are found by people who bother to spend time to bring lost items to the reporting points in NUS are published on the RepoApp. It is far more likely that Scenarios 2 and 3 occur. As such, Losters who go on to RepoApp expecting to find their lost item are likely to end up disappointed, try their luck in unofficial groups or give up.\nCompetitor Analysis Our main competitors for LNF in NUS are the RepoApp and telegram groups. Through analysing their weaknesses, we identify problems FindNUS needs to tackle.\nWith the user stories, we narrowed down the failure of RepoApp and Telegram groups as a effective LNF system to a few, specific key issues.\nIt\u0026rsquo;s inconvenient to submit lost items2, leading to low utilization of RepoApp and the proliferation of telegram groups RepoApp is not optimised for mobile and is uncomfortable to use3 There are no pictures of the actual item that is found\nInconsistent item descriptions (location, category) for both telegram and RepoApp\nBad search functionality. Users are unable to search by category on RepoApp and telegram users must filter through dozens of groups and their hundreds of messages.\nUsers that lost something must actively check the website for their lost item\nAim of FindNUS With the 6 identified problems we identified, we want to tackle those with FindNUS.\nFindNUS aims to be super accessible for everyone - the losters and founders. In short, we make it easy to submit items and search for them.\nWhat makes FindNUS different Unlike RepoApp or the ragtag band of telegram groups, FindNUS is different because we aim to\nProvide a flexible submission system that accommodates all 3 Finder scenarios. Have an Intuitive4 and User-friendly Search Platform\nThis is done by using images, standardised categories, and text-based searches to make the searching process more natural. Be Mobile-optimised Next: Project Scope With these goals in mind, we move on to the project scope where we lay down the timeline for development of FindNUS.\nPun unintended.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWhile RepoApp suffers from a lack of listings – the Lost and Found telegram group is buzzing with activity. The listings on RepoApp barely change. This is because Finders are less likely to engage in Scenario 1.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMobile is the go-to interface for most users, especially when they are on-campus and on-the-move (which is usually when they realise that they lost something)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWhat makes searches intuitive? The ability to handle minor typos and search plainly using text without the need for advanced keyword wrangling like AND/OR, EXCLUDE, etc that you may see in other complex search systems. We achieve this by leveraging on ElasticSearch.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":15,"href":"/scope/","title":"Project Scope","parent":"","content":" Milestone 1 Frontend Backend Etc Milestone 2 Frontend Backend Milestone 3 (Edge Features) Frontend Backend Beyond Orbital Milestone 1 In this milestone, we focussed on getting a MVP website out.\nWe aimed (and managed) to get the following core features done:\nA live webpage up and running User Authentication (Login) Retrieval of demo items from database Frontend Design Mockups Working Backend Microservice Architecture Extensive research into FindNUS\u0026rsquo; technical design Divide and conquer: We categorised the tasks into Frontend, Backend and other subtasks.\nFrontend Frontend Architecture Frontend Design Mockups App routing between home and login page User authentication via Firebase Interfacing with Backend API (GET item) Backend Backend Architecture Build HTTP Router to serve FindNUS RESTful API Authenticate requests using Firebase API Simple CRUD operations with MongoDB Dockerize :whale: the backend Simple CI/CD with Github actions and Using heroku\u0026rsquo;s docker container registry Extensive research to choose the best backend stack Document backend API using OpenAPI3.0 specs Etc Use of \u0026lsquo;Kanban\u0026rsquo; style boards in Github Projects to manage project Milestone 2 In this milestone, we focussed on building the core features of FindNUS. We aimed to complete the following:\nEnd to End CRUD of lost and found items Stupidly Simple Searching (SSS) of found items Preview on homepage of recent found items CICD for frontend and backend Frontend Item Submission Styling Form field validation User profile styling Loster User Dashboard UI Integrate with backend to get preview of recent items Filter preview by category Github Actions integration for CI/CD Backend Dockerize a \u0026lsquo;Item\u0026rsquo; microservice to handle CRUD requests Use RabbitMQ as Message Brokering for inter-microservice communication Setup ElasticSearch database and synchronisation logic with MongoDB Create Stupid Simple Searching endpoint Fully implement CRUD endpoints: POST PATCH GET DELETE lost and found items Pagination logic for larger GET requests (frontend\u0026rsquo;s preview) Integrate CRUD process with Imgur API to offload image storage and retrieval More rigorous Unit Testing, with tailored testcases Milestone 3 (Edge Features) In this milestone we aimed to increase the complexity of our project by making use of Natural Language Procesing, Geocoding + Map data and Automated Emailing to make FindNUS smarter :brain: and more user-centric :family:.\nOn-demand Lookout service powered by NLP to help Losters search the database for possible matches to their lost item Geocoding and Embedded Map UI Email Lookout Subscription service User dashboard interface improvements Frontend New features:\nGeocoding Show addresses matching location query when submitting item Display map after selecting location Display map when viewing items with plus code Item viewing Pagination for item peeking on home page Allow users to select number of items to display per page Allow users to filter items by category and date First Time Users Users are can input their name and email address upon login (optional) Lookout Users can now subscribe to email notifications for possible item matches (Email verification required) Improvements to UI/UX:\nResponsive page design for use with mobile and tablet devices Hamburger menu for navigation on smaller devices Media queries for various pages Show matching items for lost items (Using Natural-Language Processing as explained in FindNUS/backend#151) Allow users to input 8-digit phone numbers starting with 8 or 9 (Valid Singapore mobile number) Implement sticky item filter menu for non-mobile devices for ease of access to filters Hide overflowing text for preview items with long names and locations Improve image loading speed with Imgur thumbnails Allow photos to be removed when uploading or editing an item Backend Creation of Lookout smart service using Natural Language Processing technology Creation of Email subscription service as an add-on to the Lookout service Integration of geolocation data in database schema Beyond Orbital Beyond Orbtial, we aim to launch FindNUS for actual use and see how it performs under real-world usage. If we have enough data, we can look into expanding FindNUS to do things such as detect spam :robot: from ham :meat_on_bone: in the item submission, as well as see how we can leverage QR codes around lost hotspots in campus to quickly submit items on-the-go.\n"},{"id":16,"href":"/ms2/swe/","title":"Software Engineering Documentation","parent":"Milestone 2 README","content":" Table of Contents Sprint Code Review Frontend DRY Principle Unit Testing CI/CD Continuous Integration Continuous Delivery Backend API Documentation README: Backend REST API documentation Unit Testing CI/CD Continuous Integration Continuous Delivery Sprint We follow a sprint of two weeks, tracked via Github Projects. This is a snapshot of the three sprints that we have done so far in the project: Code Review During our fortnightly meeting with our mentor, code reviews were done by the mentor and we worked on implementing changes based on the review.\nFrontend DRY Principle We adhere to the Don\u0026rsquo;t Repeat Yourself (DRY) principle, which is highly utilised in React components. This allows us to reduce the possibility of introducing errors, and have more predictable code.\nBack to top Unit Testing We use Jest and React Testing Library to ensure code functionality in our application. For more information, click here.\nBack to top CI/CD Continuous Integration New pushes and pull requests are automatically tested with GitHub Actions\nContinuous Delivery When a pull request is opened to merge to either the production (main) or development (dev) branch, a deploy preview is triggerred and Netlify attempts to build a preview which can be tested by the developer, before the changes are merged into the base branch. If the build fails, new commits can be pushed and the build is triggerred again.\nUpon merging, the target branch is automatically built and deployed.\nBack to top Backend API Documentation README: Backend REST API documentation Good API documentation is good SWE practice for backend. It reduces ambiguity in API usage and is important for knowledge retention for when new developers come and old developers go. This industry standard also makes it possible for computers to know how to interface with the API. We documented the backend API using the OpenAPI3 specification.\nSnippet from our yaml docs on how the OpenAPI3 specs can look like:\npaths: /item: post: description: | Add new Lost item to be put on Lookout on the database. parameters: - in: header name: Authorization description: Firebase ID token of user required: true schema: type: string example: \u0026#34;Authorization: my-firebase-idToken\u0026#34; requestBody: description: Callback item payload content: \u0026#39;application/json\u0026#39;: schema: $ref: \u0026#34;#/components/schemas/NewItem\u0026#34; responses: \u0026#39;200\u0026#39;: description: Item registered into database \u0026#39;400\u0026#39;: description: Rejected new item into database \u0026#39;401\u0026#39;: description: Firebase credentials not invalid This is not so human readable, so we made use of open source openapi to markdown generator to develop Human-friendly docs.\nBack to top Unit Testing Code testing is covered in depth under the code test section. You can read more about it here.\nCI/CD We leveraged Github Actions and Docker to automate testing and continuously deploy our code.\nThis ensures that code works properly on a proper End to End environment before it goes live to production. Overall, CI/CD is used to (regressively) test code and automate the deployment process to smoothly deploy changes.\nSnippet of all CI/CD workflows in action: Continuous Integration Continuous integration is done whenever a pull request is made to the UAT or Production environments. If a microservice has changes, it will run all available unit tests to ensure that changes in one portion of the microservice did not break everything else.\nExample of Passing Unit Test:\nExample of Failing Unit Test that helped us troubleshoot issues before deploying to a live environment:\nContinuous Delivery Continuous delivery is done by pushing built Docker containers into Heroku\u0026rsquo;s docker registry. Various deployment parameters are configured using github actions, and a synchronised, common runtime is instantiated by building a docker container using dockerfiles\nContinuous Delivery Sample Job\nHeroku logs on deployment Back to top Back to top "},{"id":17,"href":"/technical/swe/","title":"Software Engineering Documentation","parent":"Technical Documentation","content":" Table of Contents Sprint Code Review Frontend DRY Principle Unit Testing CI/CD Continuous Integration Continuous Delivery Backend API Documentation README: Backend API Documentation Unit Testing CI/CD Continuous Integration Continuous Delivery Sprint We follow a sprint of two weeks, tracked via Github Projects. This is a snapshot of our Sprint board:\nCode Review During our fortnightly meeting with our mentor, code reviews were done by the mentor and we worked on implementing changes based on the review.\nFrontend DRY Principle We adhere to the Don\u0026rsquo;t Repeat Yourself (DRY) principle, which is highly utilised in React components. This allows us to reduce the possibility of introducing errors, and have more predictable code.\nBack to top Unit Testing We use Jest and React Testing Library to ensure code functionality in our application. For more information, click here.\nBack to top CI/CD Continuous Integration New pushes and pull requests are automatically tested with GitHub Actions\nContinuous Delivery When a pull request is opened to merge to either the production (main) or development (dev) branch, a deploy preview is triggerred and Netlify attempts to build a preview which can be tested by the developer, before the changes are merged into the base branch. If the build fails, new commits can be pushed and the build is triggerred again.\nUpon merging, the target branch is automatically built and deployed.\nBack to top Backend API Documentation README: Backend API Documentation Good API documentation is good SWE practice for backend. It reduces ambiguity in API usage and is important for knowledge retention for when new developers come and old developers go. This industry standard also makes it possible for computers to know how to interface with the API. We documented the backend API using the OpenAPI3 specification.\nSnippet of how the YAML OpenAPI3 specs look like:\npaths: /item: post: description: | Add new Lost item to be put on Lookout on the database. parameters: - in: header name: Authorization description: Firebase ID token of user required: true schema: type: string example: \u0026#34;Authorization: my-firebase-idToken\u0026#34; requestBody: description: Callback item payload content: \u0026#39;application/json\u0026#39;: schema: $ref: \u0026#34;#/components/schemas/NewItem\u0026#34; responses: \u0026#39;200\u0026#39;: description: Item registered into database \u0026#39;400\u0026#39;: description: Rejected new item into database \u0026#39;401\u0026#39;: description: Firebase credentials not invalid This is not so human readable, so we made use of open source openapi to markdown generator to develop Human-friendly docs.\nBack to top Unit Testing Code testing is covered in depth under the code test section. You can read more about it here.\nCI/CD We leveraged Github Actions and Docker to automate testing and continuously deploy our code.\nThis ensures that code works properly on a proper End to End environment before it goes live to production. Overall, CI/CD is used to (regressively) test code and automate the deployment process to smoothly deploy changes.\nSnippet of all CI/CD workflows in action: Continuous Integration Continuous integration is done whenever a pull request is made to the UAT or Production environments. If a microservice has changes, it will run all available unit tests to ensure that changes in one portion of the microservice did not break everything else.\nExample of Passing Unit Test:\nExample of Failing Unit Test that helped us troubleshoot issues before deploying to a live environment:\nContinuous Delivery Continuous delivery is done by pushing built Docker containers into Heroku\u0026rsquo;s docker registry. Various deployment parameters are configured using github actions, and a synchronised, common runtime is instantiated by building a docker container using dockerfiles\nContinuous Delivery Sample Job\nHeroku logs on deployment Back to top "},{"id":18,"href":"/ms2/technical/","title":"Technical Documentation","parent":"Milestone 2 README","content":"In this page, we talk about the nitty gritty integration and technical details for FindNUS.\nFrontend Technical Documentation Backend Technical Documentation "},{"id":19,"href":"/technical/","title":"Technical Documentation","parent":"","content":" Introduction This section details the technical nitty-gritty of FindNUS:\nFrontend Overview This section covers the architectural and logic flow for the frontend\nBackend Overview This section covers the architectural overview for the RESTful API Backend and the various integrations of technologies, from MongoDB to ElasticSearch.\nUser Testing We document our user testing framework, feedback obtained, and the actionable outcomes of it\nUnit Testing We discuss how we validate code correctness using Unit Testing\nSoftware Engineering We discuss how we practiced good software engineering practices while building FindNUS, such as using OpenAPI docs, Sprints and CI/CD\n"},{"id":20,"href":"/ms2/uiux/","title":"UI UX and Testing","parent":"Milestone 2 README","content":"Learn more about FindNUS\u0026rsquo; User and Code testing methodologies.\n3.5 User Testing 3.6 Code Testing "},{"id":21,"href":"/userguide/","title":"User Guide","parent":"","content":" Table of Contents Before you start About FindNUS Features Accessing the application Recommended browsers How to Search for an item Submit an item Found item Lost item Register for an account Log in to FindNUS View recently found items View your submitted lost items Edit your submitted lost item Delete your submitted lost item Subscribe to Email notifications Method 1: During item submission Method 2: View item Unsubscribe from Email notifications Request for verification email Frequently Asked Questions Before you start About FindNUS Welcome to FindNUS. FindNUS is a lost and found item management system which aims to supplement existing NUS lost and found system in National University of Singapore (NUS) by reducing the barriers for item finders to submit an item online. As such, item losters are more likely to find an item which they have lost on top of items which only make it to the security personnel.\nFeatures Item submission Geocoding of location (Convert location name into actual coordinates) Item filtering: View items by category or by date User dashboard Profile View submitted items (Edit or delete items that you have submitted) View matching items (Items which are possible matches for your lost item) Email notifications: Subscribe to emails when a found item similar to your lost item is submitted Accessing the application The application can be accessed at https://findnus.netlify.app\nRecommended browsers We recommend using the latest versions of Google Chrome and Chromium-based browsers.\nBrowser Version Google Chrome Chromium 103.0.5060.134 (Official Build) (64-bit) Firefox 102.0.1 (64-bit) Brave 1.41.100 How to Search for an item Back to top Submit an item Note 1: The following fields are compulsory.\nItem Description Category Date Location (If you are unable to select a location, please refine your search keywords) Note 2: For subscribing to email notifications, email must be verified first.\nFound item Back to top Lost item Note: You must be logged in to submit lost items.\nBack to top Register for an account Note: You may choose to not enter your name or email by using the navigation buttons. However, you will be required to input them if you want to subscribe to email notifications\nBack to top Log in to FindNUS Back to top View recently found items Back to top View your submitted lost items Note: You must be logged in to view your items.\nBack to top Edit your submitted lost item Note: You must be logged in to edit your items.\nBack to top Delete your submitted lost item Note: You must be logged in to delete your items.\nBack to top Subscribe to Email notifications Note: You must add and verify your email to subscribe to email notifications.\nBack to top Method 1: During item submission Back to top Method 2: View item Back to top Unsubscribe from Email notifications Back to top Request for verification email Back to top Frequently Asked Questions No. Question Answer 1 How do I submit a lost item? You need to be logged in to so do. 2 I cannot find the verification email. Check your junk/spam folder or request for another email 3 I did not receive emails for my subscribed items Check your junk folder! If there\u0026rsquo;s nothing, it may also be due to no good matches for your lost item :( 4 I am seeing a \u0026ldquo;Page Not Found\u0026rdquo; error, what do I do? Type https://findnus.netlify.app in the url bar to get back on track! 5 Is my data secure? Your data is securely managed by Google\u0026rsquo;s Firebase authentication. 6 What do you do with my personal data? We only use your personal data for authentication and email subscriptions that you consent to. 7 I encountered an error when using the application. Please contact the developers or email us 8 How do I delete my account? If you wish to remove your personal data from our database, please email us and allow us 7 working days to process your request. 9 How do I submit feedback about the application? You may contact the developers or email us If you have other questions, feel free to contact the developers. You may find their contact details here\nBack to top "},{"id":22,"href":"/ms2/uiux/usertesting/","title":"User Testing","parent":"UI UX and Testing","content":"The testing of the application can be broken down into functional and non-functional tests\nTable of Contents Functional Testing Unit and Integration Testing Non-functional Testing Usability Testing Documentation Testing Functional Testing Unit and Integration Testing For frontend, we perform unit and integration testing with Jest and React Testing Library. For backend, unit testing is conducted with golang’s built-in testing function: go test .., while integration testing is deployed to the User Acceptance Testing backend. For more information, click here\nBack to top Non-functional Testing Usability Testing To perform usability testing, the tester should to complete the following tasks\nTask Todo Expected Result Search Search for the item \u0026ldquo;iPhone 13\u0026rdquo; and view it User should obtain the following item\nPeek View recently uploaded items User should minimally see these items\nFilter Filter recent items with the category \u0026ldquo;Electronics\u0026rdquo; User should minimally see this item\nSubmit an item Submit a found item of your choice (image is optional) User should see their uploaded item (Possibly requires refresh after redirect) Login Attempt to login using either their own mobile number, an international phone number from this page or the following test account:\nPhone Number: +6511111111 (no spaces)\nOTP: 111111 For the test account, user will see the following information:\nFor other accounts, a different user ID will be displayed Dashboard Items View items uploaded with the test account above User should minimally see this item\nLogout Attempt to logout of the application Redirected to home page with login option Back to top Documentation Testing A sample of the API documentation can be found here, and the deployment can be accessed at https://findnus.herokuapp.com/\nSearch Query Example\nRefer to GET /search for more details.\nTo perform a search query for the item \u0026ldquo;Airpods\u0026rdquo;, you may perform a GET request at the /search endpoint with the following URL: https://findnus.herokuapp.com/search?query=Airpods You should expect to receive the following response:\n[ { \u0026#34;Id\u0026#34;:\u0026#34;62b82df7a5d9182afd9665a0\u0026#34;, \u0026#34;Name\u0026#34;:\u0026#34;Airpods\u0026#34;, \u0026#34;Date\u0026#34;:\u0026#34;2022-05-18T00:00:00Z\u0026#34;, \u0026#34;Location\u0026#34;:\u0026#34;UTown Bus Stop\u0026#34;, \u0026#34;Category\u0026#34;:\u0026#34;Electronics\u0026#34;, \u0026#34;Item_details\u0026#34;:\u0026#34;Please call me if found, thank you!!\u0026#34;, \u0026#34;Image_url\u0026#34;:\u0026#34;https://i.imgur.com/c5MuKsu.jpg\u0026#34; } ] Which is equivalent to the following item\nBack to top "},{"id":23,"href":"/technical/usertesting/","title":"User Testing","parent":"Technical Documentation","content":" Table of Contents User Testing Framework User Testers Probing Questions User Testing Conduct Task List General Questions Optional: Documentation Testing Feedback Received Feature Requests Usability Issues Critical Issues Misc Issues/Nitpicks New Deliverables User Testing Framework We conducted User Testing of the application by conducting a Think Aloud test with our testers.\nIn the test, we defined a set of tasks broken down into functional and non-functional tests for the user to complete. We encouraged the tester to \u0026rsquo;think aloud' by narrating their thought processes while they are completing the tasks.\nUser Testers Our target audience are NUS students and staff. Hence, for the user testing, we recruited some NUS students who have not seen our web application before to test out out website.\nProbing Questions If the user is very silent during the test or has interesting think aloud observations, we will ask probing questions to futher elicit responses and get a deeper insight into the possible difficulties that they faced.\nQuestion Intent What\u0026rsquo;s going through your mind? Find out why the tester is silent. They may be stuck or deep in thought that contains valuable feedback Why do you say that {some observation}? Probe the tester for their rationale. For example, the user says that the item submission form is hard to use. What do you think is confusing about {task}? If the user is confused about a task, find out exactly what makes it confusing How did you feel about doing {task}? Understand how the users feel about doing certain things. Emotions such as frustration and anxiety may be indicative of a deeper problem in the UX of the application User Testing Conduct We got the user testers to complete the following tasks chronologically as a form of usability testing. While the users performed the tasks, we encouraged them to think aloud and used probing questions as defined above to help maximise the insights that the testers may have.\nThese were the tasks that we got the users to do:\nTask List Task Name Task Details Expected Result Searching Search for the item \u0026ldquo;iPhone 13\u0026rdquo; and view it User should obtain the following item\nTypo testing Search for the item \u0026ldquo;ipho 1a\u0026rdquo; User should still be able to obtain the following item in the search results\nPreviewing View recently uploaded items User should minimally see these items\nFiltering Filter recent items with the category \u0026ldquo;Electronics\u0026rdquo; User should minimally see this item\nSubmit an item Submit a found item of your choice (image is optional) User should see their uploaded item (Possibly requires refresh after redirect) Login Attempt to login using either their own mobile number, an international phone number from this page or the following test account:\nPhone Number: +6511111111 (no spaces)\nOTP: 111111 For the test account, user will see the following information:\nFor other accounts, a different user ID will be displayed Dashboard Items View items uploaded with the test account above User should minimally see this item\nLogout Attempt to logout of the application Redirected to home page with login option Back to top General Questions After the Think Aloud test, we asked each participant all of the following questions.\nQuestion Intent What are the most memorable features of FindNUS? Appraise which FindNUS features had the most perceived value and impact to the user. If you could change one thing about FindNUS, what would you change? Directly query for pain points that the user may have. Do you think you will use FindNUS?\nWhat makes you say yes/no? Find out how easily adoptable our application is to the regular user. How do you think FindNUS compares to the current lost and found system in NUS? Find out how competitive FindNUS is in terms of usefulness compared to the telegram groups and RepoApp. Optional: Documentation Testing For the NUS students who had technical programming knowledge, we also asked them give feedback on our backend API documentation for readability and usability.\nA sample of the API documentation can be found here, and the deployment can be accessed at https://findnus.herokuapp.com/\nFeedback Received We then compiled all of the feedback we had recieved from the Think Aloud testing and General Questions are organised them into a few broad categories. These organised feedback are compiled below:\nFeature Requests A user commented that they would prefer to be able to narrow down the search to a range of dates as it will make it the experience less cluttered and more focussed Usability Issues Phone numbers must be prefixed with +65 for the OTP to work.\nMost testers assumed that the number without the country code will work Images took a long while to load for some of the items Items with very long names and locations have their text exceeding the item card Critical Issues A few users tested the website on their phone. The website did not render nicely for them and made the experience much more frustrating for them. Some users commented that if there are many found items on the dashboard, it would make it harder for them to search for their lost item. It may be good if they can get item reccommendations for their lost items, such as Shopee/Amazon \u0026lsquo;similar items\u0026rsquo; reccomendations A significant number of testers feedbacked that if the user base is not strong, there is not much point to using the web application Misc Issues/Nitpicks The background image for the main website seems quite random and irrelevant to the lost and found theme There is some unused white space in the specific item view page The submission buttons for Lost and Found items are quite big The login page seems a bit empty New Deliverables With these feedback, we formulated a set of deliverables to act on the user feedback in Milestone 3. These extra deliverables can be found in the Project Scope MS3 Featureset. Nonetheless, we list the deliverables here as well.\nIdentified Deliverables:\nDate filter for item preview on homepage (1) Allow users to input 8-digit phone numbers starting with 8 or 9 for Singapore numbers (2) Hide overflowing text for preview items with long names and locations (2) Image loading optimisation via thumbnailing Imgur links (3) Fix the text overflow bug (4) Mobile optimisation (5) Media (Viewport) queries for various pages Implement sticky item filter menu for non-mobile devices for ease of access to filters Smart Item Finder (i.e. Lookout Service) (6) "},{"id":24,"href":"/","title":"","parent":"","content":" FindNUS README :telescope: By Team Lost Engineers\nName Scope GitHub Email Jin Xuan Frontend https://github.com/jinxuan-owyong jinxuan.owyong@u.nus.edu Nicholas Backend https://github.com/nichyjt nicholas.yek@u.nus.edu Foreword \u0026amp; Introduction Welcome to the FindNUS documentation website! This is a living document showcasing our team\u0026rsquo;s efforts during Summer 2022.\nWe would like to take this opportunity to express our gratitude to Prof. Jin Zhao for giving us this opportunity to take up Orbital. His enthusiasm and care for the students under Orbital made the experience memorable and meaningful. We are greatly appreciative of his timely reminders and many opportunities provided to level-up our software engineering and computing skills thorugh the Mission Controls.\nWe would also like to thank our mentor Ruiping Liu for taking time out of his busy schedule to mentor us for this project. His sharp insights and industry knowledge helped identify gaps in our understanding and guide us to develop a technically comprehensive project. Mentor Ruiping was truly a force multiplier in this project, as his critical appraisal helped give FindNUS the technical edge that we believe squares up to industry standards.\nTo our user testers, fellow peer evaluators and our Advisor Hardik Narang, thank you for your invaluable feedback and time spent analysing our project. Your feedback helped push FindNUS\u0026rsquo; development and helped us identify issues with our project. Without it, FindNUS\u0026rsquo; development would surely be lacking. We wish the best of luck to our fellow peer evaluators for the smooth evaluation of their projects.\nTable of Contents FindNUS README :telescope: Foreword \u0026amp; Introduction Table of Contents Quickstart Proposed Level of Achievement What\u0026rsquo;s New? :stars: Deployments Codebase Poster Video Features Edge Features Motivation - Why FindNUS? Project Scope User Guide Developer Guide Technical Documentation Project Logs Milestone 1 Milestone 2 Milestone 3 Quickstart You are a\u0026hellip;\nUser wondering how to navigate FindNUS? Click here.\nDeveloper wondering how to work on FindNUS? Click here.\nEmployer interested in FindNUS\u0026rsquo;s user research and design ? Click here. Software Engineer interested in the inner workings + engineering practices of FindNUS? Click here.\nEvaluator for Orbital? Start here.\nProposed Level of Achievement FindNUS aims to achieve Artemis level.\nWhat\u0026rsquo;s New? :stars: In this milestone, we focussed on adding quality of life features to make the searching for lost items much more seamless and \u0026lsquo;smart\u0026rsquo;. The full release notes for Milestone 3 are here.\nCreated an on-demand Lookout service powered by NLP to help Losters search the database for possible matches to their lost item Created an asynchronus Lookout service that Losters can subscribe to by email to recieve updates on any new findins Geolocation UI User dashboard interface improvements Better item preview functionality with more filtering options Deployments FindNUS is live @ findnus.netlify.app. If you are here to try FindNUS out, click on the link!\nStaging (User Acceptance Testing) Environment @ transcendent-beijinho-1ca1f9.netlify.app if you\u0026rsquo;re interested in that instead.\nCodebase Our github repository.\nPoster Video Features The full featureset is documented under our project scope, but for visibility, this is a brief summary of what FindNUS can do.\nAuthentication (OTP)\nUsers who want to submit a lost item will need to create an account. The Loster dashboard and lost item submission pages are protected routes that will only allow access if the user has been authenticated \u0026amp; has an account with FindNUS\nItem Preview on Homepage\nUsers should be able to see the latest found items on the homepage. Their item may be recently found and added to the database.\nFilter Preview by Category and Date\nUsers can filter the latest found items by category on the homepage if they are absolutely sure of their lost item category, such as Cards.\nCreation of Lost/Found Item\nUsers are able to fill up a simple form to seamlessly submit a Lost \u0026amp; Found item to the database.\nLoster User Dashboard\nLosters should have a dashboard to view and edit their Lost item records and to view their various information.\nEditing \u0026amp; Deleting details of the Lost item\nUsers can edit and delete their lost item in their dashboard\nStupid Simple Searching (SSS) for Found items\nUsers can intuitively just search for whatever on the searchbar. SSS is able to handle minor typos and knows how to handle your query. No need for joining queries or fumbling with logical AND/OR operators.\nEdge Features These are additional features we developed for Milestone 3.\nGoogle Maps Integration\nAbility to specify on Google maps exactly on the Lost and Found item whereabouts. Includes embedded google maps UI as well as ability to autodetect locations in the form field.\nNLP-powered Lookout Service\nLet FindNUS search for you on-demand. Based on your lost item, FindNUS uses NLP and ElasticSearch magic to find found items that are possible matches for your lost item.\nSubscribe to Lookout Email Notifications\nBased on our lost item that you subscribed to, FindNUS will periodically search using the Lookout Service for possible item matches, and email you about them.\nMore robust preview filtering\nSome users may want to narrow down the preview filters. We added the option of filtering preview results by date and allowing larger pagination values.\nEmail verification\nUsers can be verified via email which will unlock more features of the webiste to them, such as Item Lookout Subscriptions.\nMotivation - Why FindNUS? FindNUS was created because we feel that the current Lost and Found (LNF) system in NUS sucks.\nIt is decentralized and messy. The official Lost and Found vendor that serves NUS, RepoApp and unofficial telegram groups don’t put user experience first and are generally hard to navigate.\nIn our Problem Research Page, We deep dive into our project aim and deepened our understanding of the LNF problem on campus with our where we document our user stories and LNF competitor analysis.\nProject Scope In our Project Scope, we document each Orbital milestone and what features we have accomplished and set forth to do.\nUser Guide Need a detailed guide on navigating FindNUS? Click here for the User Guide.\nDeveloper Guide Want to help out? Click here for the Developer Guide.\nTechnical Documentation Our Technical Documentation covers a few areas of interest:\nChallenges Encountered\nThe development journey for FindNUS was full of ups and downs. We document some significant issues we faced during the development of FindNUS. Architectural Overview\nWe cover key features and architectual design choices User Validation \u0026amp; Testing\nWe cover how we get users to test our app and make changes from there Software Engineering Practices\nWe document our fortnitely sprints, unit testing and more software engineering nuances in our project Project Logs Click the headers to see our project logs in excel format:\nMilestone 1 Milestone 2 Milestone 3 "},{"id":25,"href":"/tags/","title":"Tags","parent":"","content":""}]